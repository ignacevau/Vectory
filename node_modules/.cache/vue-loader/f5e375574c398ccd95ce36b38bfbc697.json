{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue","mtime":1580335339769},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n\r\nimport paper from \"paper\";\r\nimport Tool from \"../Tool.vue\";\r\nimport { mapMutations, mapState } from \"vuex\";\r\nimport { bus, Action } from \"@/main.js\";\r\nimport Data from '@/Data.js';\r\nimport { GuideLines } from '@/mixins/GuideLines.js';\r\n\r\nexport default {\r\n  mixins: [GuideLines],\r\n  name: \"ToolSelect\",\r\n  data: function() {\r\n    return {\r\n      snappedY: false,\r\n      snappedX: false\r\n    }\r\n  },\r\n  computed: {\r\n    ...mapState([\r\n      \"ACTIVE_TOOL\", \r\n      \"TOOLSELECT\", \r\n      \"OBJECTS\", \r\n      \"SELECTED\", \r\n      \"ACTIONS\"\r\n      ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      \"SET_ACTIVE\",\r\n      \"ADD_SELECT\",\r\n      \"DESELECT\",\r\n      \"ADD_ACTION\",\r\n      \"UNDO\"\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\");\r\n\r\n      bus.$emit(\"activate-select\");\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n//#region Assigning\r\n    var el = document.querySelector(\"#tool-select\");\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var mouseEvent;\r\n\r\n    // Need this to create custom drag function\r\n    var mouseDown = false;\r\n\r\n    // Path over which the mouse currently hovers\r\n    let hoverItem;\r\n    var hoverSelection = new Path();\r\n    hoverSelection.selectable = false;\r\n\r\n    // Shadow paths while transforming path\r\n    let shadowPaths = [];\r\n\r\n    // Transform rectangle cache\r\n    var lastTransformRect;\r\n\r\n    // The selection rectangle with transform points\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      leftCenter: null,\r\n      rightCenter: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null,\r\n      bottomRight: null\r\n    };\r\n\r\n    // Updated through zoom\r\n    var transformBoxSize = 7 / view.zoom;\r\n    var transformBoxWidth = 2 / view.zoom;\r\n\r\n    // Object with transform information\r\n    var transform = {\r\n      // Scaling\r\n      pivot: null,\r\n      dir: \"\", // topLeft, topMiddle, ...\r\n\r\n      scale_facH: null,\r\n      scale_facW: null,\r\n    };\r\n\r\n    const state = {\r\n      isHovering: false,\r\n      isScaling: false,\r\n      isDragging: false,\r\n      isSelecting: false,\r\n      \r\n      snapVecLeftX: null,\r\n      snapVecRightX: null,\r\n      snapVecTopY: null,\r\n      snapVecBottomY: null\r\n    }\r\n\r\n    // The relative distances used in scaling\r\n    var relH;\r\n    var relW;\r\n\r\n    var selectRectAnchor = null;\r\n\r\n    // Selection rectangle\r\n    let selectRectPath = new Path();\r\n\r\n    var _lastMousePos;\r\n    var mouseDelta;\r\n\r\n    var flippedV = false;\r\n    var flippedH = false;\r\n    var lockScaleX = false;\r\n    var lockScaleY = false;\r\n    var point;\r\n\r\n    // Object containing the data before the scaling, used for undo and shift/control modifiers\r\n    var initTransfData = {\r\n      height: null,\r\n      width: null,\r\n      pivot: null,\r\n      center: null\r\n    };\r\n\r\n    var action = {\r\n      move: new Action(\"move\", {\r\n        startPos: null,\r\n        endPos: null,\r\n        paths: null\r\n      }),\r\n      scale: new Action(\"scale\", {\r\n        paths: null,\r\n        pivot: null,\r\n        handle_init: null,\r\n        handle_end: null,\r\n        lockX: false,\r\n        lockY: false,\r\n        shift: false\r\n      })\r\n    };\r\n//\r\n\r\n//#region Functions\r\n    let getSelection = () => {\r\n      return this.SELECTED;\r\n    }\r\n\r\n    let getUngrouped = (items) => {\r\n      if(items.length == 0) {\r\n        return [];\r\n      }\r\n\r\n      let result = [];\r\n\r\n      for(let i=0; i<items.length; i++) {\r\n        let item = items[i];\r\n\r\n        if(item.type == \"shape\")\r\n          result.push(item)\r\n        else if(item.type == \"group\") {\r\n          for(let j=0; j<item.children.length; j++) {\r\n            result.push(...getUngrouped([item.children[j]]));\r\n          }\r\n        }\r\n\r\n        // Error catching - prevent infinite loop\r\n        else {\r\n          console.error(\"Unknown item type! Item was: \" + item);\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function ResetHover() {\r\n      state.isHovering = false;\r\n\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        hoverSelection.remove();\r\n      }\r\n    }\r\n\r\n    function DrawHoverSelection(path) {\r\n      hoverSelection = path.clone();\r\n      Object.assign(hoverSelection, {\r\n        selectable: false,\r\n        strokeColor: \"#33b5ff\",\r\n        strokeWidth: 2 / paper.view.zoom\r\n      });\r\n    }\r\n\r\n    function DrawShadowPaths(paths) {\r\n      if(shadowPaths.length != 0) {\r\n        RemoveShadowPaths();\r\n      }\r\n\r\n      shadowPaths = [];\r\n      for(let i=0; i<paths.length; i++) {\r\n        let _path = paths[i].clone();\r\n        _path.selectable = false;\r\n        _path.selected = false;\r\n        _path.dashArray = [5, 5];\r\n        _path.opacity = 0.2;\r\n        shadowPaths.push(_path);\r\n      }\r\n    }\r\n\r\n    function RemoveShadowPaths() {\r\n      if(shadowPaths.length != 0) {\r\n        for(let i=0; i<shadowPaths.length; i++) {\r\n          shadowPaths[i].remove();\r\n        }\r\n        shadowPaths = [];\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverPath(item) {\r\n      if (!item.selected) {\r\n        DrawHoverSelection(item);\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverTransform(item) {\r\n      document.body.style.cursor = item.cursorType;\r\n      transform.pivot = item.opposite;\r\n    }\r\n\r\n    // Remove the selection box with transform points\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    // Draw selection box with transform points\r\n    function drawTransformBox(rect) {\r\n      if (rect) {\r\n        lastTransformRect = rect;\r\n      }\r\n\r\n      if (!lastTransformRect) return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(lastTransformRect);\r\n      transformRect.strokeColor = \"black\";\r\n      transformRect.selectable = false;\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n\r\n      // Calculate the positions\r\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize / 2);\r\n      var topMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n      var topRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var middleLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n      var middleRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var bottomLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\r\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\r\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\r\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\r\n\r\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\r\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize);\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\r\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n      // Set type\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].type = \"transformPoint\";\r\n        }\r\n      });\r\n\r\n      // Set cursor type\r\n      transformPoints.topLeft.cursorType = \"nw-resize\";\r\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\r\n\r\n      transformPoints.topMiddle.cursorType = \"n-resize\";\r\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\r\n\r\n      transformPoints.topRight.cursorType = \"ne-resize\";\r\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\r\n\r\n      transformPoints.leftCenter.cursorType = \"e-resize\";\r\n      transformPoints.rightCenter.cursorType = \"e-resize\";\r\n\r\n      // Set names\r\n      transformPoints.topLeft.name = \"topLeft\";\r\n      transformPoints.topRight.name = \"topRight\";\r\n      transformPoints.topMiddle.name = \"topCenter\";\r\n\r\n      transformPoints.leftCenter.name = \"leftCenter\";\r\n      transformPoints.rightCenter.name = \"rightCenter\";\r\n\r\n      transformPoints.bottomLeft.name = \"bottomLeft\";\r\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\r\n      transformPoints.bottomRight.name = \"bottomRight\";\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].selectable = false;\r\n          transformPoints[point].strokeColor = \"blue\";\r\n          transformPoints[point].fillColor = \"white\";\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n    // Redraw the selection box with transform points\r\n    function updateTransformBox(bounds) {\r\n      hideTransformBox();\r\n\r\n      if (bounds) {\r\n        drawTransformBox(bounds);\r\n      } else {\r\n        drawTransformBox();\r\n      }\r\n    }\r\n\r\n    // Hide the transform points, but keep the box (e.g. while moving selection)\r\n    function HideTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = false;\r\n      });\r\n    }\r\n\r\n    function ShowTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = true;\r\n      });\r\n    }\r\n\r\n    function CreateSelectionRectanglePath({rect, strokeWidth, strokeColor, dashArray}) {\r\n      let path = Path.Rectangle(rect);\r\n      Object.assign(path, {\r\n        strokeWidth: strokeWidth,\r\n        strokeColor: strokeColor,\r\n        dashArray: dashArray,\r\n        selectable: false\r\n      });\r\n      return path;\r\n    }\r\n\r\n  //#region Group\r\n    let SelectGroup = (group) => {\r\n      if(!group.selected) {\r\n        let ungrouped = getUngrouped([group]);\r\n        for(let i=0; i<ungrouped.length; i++) {\r\n          ungrouped[i].selected = true;\r\n        }\r\n        group.selected = true;\r\n        this.ADD_SELECT(group);\r\n      }\r\n    }\r\n\r\n    function DeselectGroup(group) {\r\n      DeselectShape(group);\r\n    }\r\n\r\n    function CheckGroupIntersection(group, rect) {\r\n      // Check for every child in the group\r\n      let children = getUngrouped(group.children);\r\n      for (let j = 0; j < children.length; j++) {\r\n        // Check for intersection with selection rect\r\n        if (rect.intersects(children[j])) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckGroupInsideRect(group, rect) {\r\n      let children = getUngrouped(group.children);\r\n      for(let i=0; i<children.length; i++) {\r\n        if (children[i].isInside(rect) && children[i].selectable) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n  //#region Shape\r\n    let SelectShape = (shape) => {\r\n      if (!shape.selected) {\r\n        shape.selected = true;\r\n        this.ADD_SELECT(shape);\r\n      }\r\n    }\r\n\r\n    let DeselectShape = (shape) => {\r\n      shape.selected = false;\r\n      let index = getSelection().findIndex(x => x === shape);\r\n      if (index != -1) {\r\n        getSelection().splice(index, 1);\r\n      }\r\n    }\r\n\r\n    function CheckShapeIntersection(shape, rectPath) {\r\n      // Selection rect intersects with the shape\r\n      if (rectPath.intersects(shape) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckShapeInsideRect(shape, rect) {\r\n      // Shape is inside the selection rect\r\n      if (shape.isInside(rect) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n    // Return the opposite point on the transform box\r\n    function getOppositePoint(point, x, y, bounds) {\r\n      if (!point) {\r\n        alert(\"warning: 001\");\r\n        return;\r\n      }\r\n      var _point = point;\r\n      var opposite = bounds.center.add(bounds.center.subtract(point));\r\n\r\n      if (x) {\r\n        _point = new Point(opposite.x, _point.y);\r\n      }\r\n      if (y) {\r\n        _point = new Point(_point.x, opposite.y);\r\n      }\r\n\r\n      return _point;\r\n    }\r\n\r\n    // Get the selection rectangle\r\n    let getBounds = (shapes) => {\r\n      if (shapes.length == 0) {\r\n        return null;\r\n      }\r\n\r\n      var _temp = [];\r\n      for (var i = 0; i < shapes.length; i++) {\r\n        let item = shapes[i];\r\n\r\n        if(item.type == \"group\") {\r\n          let ungrouped = getUngrouped(item.children);\r\n          for(let j=0; j<ungrouped.length; j++) {\r\n            _temp.push(ungrouped[j].clone());\r\n          }\r\n        }\r\n        else if(item.type == \"shape\") {\r\n          _temp.push(item.clone());\r\n        }\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      var rect = _grouped.bounds;\r\n      _grouped.remove();\r\n\r\n      return rect;\r\n    }\r\n\r\n    function RedrawTransformPoints() {\r\n      Object.keys(transformPoints).forEach((point, index) => {\r\n        transformPoints[point].position = transformRect.bounds[point];\r\n      });\r\n    }\r\n\r\n    // While scaling check whether the selection should be flipped\r\n    function checkScaleFlip() {\r\n      if (relH > 0 && flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = false;\r\n      } else if (relH < 0 && !flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = true;\r\n      }\r\n\r\n      if (relW > 0 && !flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = true;\r\n      }\r\n      if (relW < 0 && flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = false;\r\n      }\r\n    }\r\n\r\n    // Handle ctrl-key presses\r\n    function handleControlKey() {\r\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\r\n\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].translate(delta);\r\n      }\r\n\r\n      transformRect.position = initTransfData.center;\r\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\r\n\r\n      action.scale.data.pivot = point;\r\n\r\n      mouseDrag(mouseEvent);\r\n    }\r\n//\r\n\r\n//#region Mouse down\r\n    \r\n    this.TOOLSELECT.onMouseDown = e => {\r\n      mouseDown = true;\r\n      _lastMousePos = e.point;\r\n\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n          state.isDragging = true;\r\n\r\n          // Hide scaling points when moving the selection\r\n          HideTransformPoints();\r\n          DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n          state.snapVecLeftX = getBounds(getSelection()).leftCenter.subtract(e.point);\r\n          state.snapVecRightX = getBounds(getSelection()).rightCenter.subtract(e.point);\r\n          state.snapVecTopY = getBounds(getSelection()).topCenter.subtract(e.point);\r\n          state.snapVecBottomY = getBounds(getSelection()).bottomCenter.subtract(e.point);\r\n\r\n          action.move = new Action(\"move\", {\r\n            paths: getUngrouped(getSelection()),\r\n            startPos: e.point,\r\n            endPos: null\r\n          });\r\n\r\n          return;\r\n        }\r\n      }\r\n\r\n      hideTransformBox();\r\n      if (state.isHovering && hoverItem.type == \"transformPoint\") {\r\n        let bounds = getBounds(getSelection());\r\n\r\n        state.isScaling = true;\r\n\r\n        // Hide scaling points when scaling the selection\r\n        HideTransformPoints();\r\n        DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n        drawTransformBox();\r\n\r\n        transform.dir = e.item.name;\r\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds);\r\n\r\n        // Updating the backup data (for shift-scale and for undo)\r\n        initTransfData.width = bounds.width;\r\n        initTransfData.height = bounds.height;\r\n        initTransfData.pivot = new Point(point.x, point.y);\r\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\r\n\r\n        switch (transform.dir) {\r\n          case \"bottomLeft\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topLeft\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomRight\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topRight\":\r\n            flippedV = true;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topCenter\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"leftCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n          case \"rightCenter\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          handleControlKey();\r\n        }\r\n\r\n        action.scale = new Action(\"scale\", {\r\n          paths: getUngrouped(getSelection()),\r\n          pivot: initTransfData.pivot,\r\n          lockX: lockScaleX,\r\n          lockY: lockScaleY,\r\n          handle_init: bounds[transform.dir],\r\n          handle_end: null,\r\n          shift: false\r\n        });\r\n\r\n        mouseDrag(e);\r\n\r\n        return;\r\n      }\r\n\r\n      transformRect = new Path();\r\n\r\n      // Mouse is not over a shape\r\n      if (!state.isHovering) {\r\n        this.DESELECT();\r\n      }\r\n\r\n      // Mouse is over a shape\r\n      if (hoverSelection) {\r\n        hoverSelection.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\r\n          // Shift key is pressed\r\n          if (e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n\r\n            this.ADD_SELECT(hoverItem);\r\n          }\r\n          // Shift key is not pressed\r\n          else {\r\n            project.deselectAll();\r\n\r\n            this.DESELECT();\r\n\r\n            SelectShape(hoverItem);\r\n          }\r\n\r\n          drawTransformBox(getBounds(getSelection()));\r\n        }\r\n      }\r\n\r\n      if (!e.item) {\r\n        project.deselectAll();\r\n        this.DESELECT();\r\n        selectRectAnchor = e.point;\r\n        state.isSelecting = true;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse move\r\n    this.TOOLSELECT.onMouseMove = (e) => {\r\n      mouseEvent = e;\r\n\r\n      // Reset cursor style\r\n      document.body.style.cursor = \"default\";\r\n      ResetHover();\r\n\r\n      // Mouse is hovering over an item\r\n      if (e.item && !state.isSelecting && !state.isDragging) {\r\n\r\n        if (e.item.selectable) {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverPath(hoverItem);\r\n        }\r\n        \r\n        // Mouse is hovering over transform-handle (not selectable)\r\n        else if(e.item.type == \"transformPoint\") {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverTransform(hoverItem);\r\n        }\r\n      }\r\n\r\n      if (state.isSelecting && !state.isHovering) {\r\n        selectRectPath.remove();\r\n\r\n        let selectRect = new Rectangle(selectRectAnchor, e.point);\r\n\r\n        selectRectPath = CreateSelectionRectanglePath({\r\n          rect: selectRect,\r\n          strokeWidth: 0.5 / view.zoom,\r\n          strokeColor: \"black\",\r\n          dashArray: [4 / view.zoom, 3 / view.zoom]\r\n        });\r\n\r\n        let objects = this.OBJECTS;\r\n        for (let i = 0; i < objects.length; i++) {\r\n          /* First, check for intersections between the shapes and the selection rectangle,\r\n            if none, check whether the shapes are inside the rectangle */\r\n            \r\n          let obj = objects[i];\r\n\r\n          // Group\r\n          if (obj.type == \"group\" && obj.selectable) {\r\n            let _isIntersect = CheckGroupIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectGroup(obj);\r\n            else {\r\n              let _isInside = CheckGroupInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectGroup(obj);\r\n              else {\r\n                DeselectGroup(obj);\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Shape\r\n          else if (obj.type == \"shape\") {\r\n            let _isIntersect = CheckShapeIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectShape(obj);\r\n            else {\r\n              let _isInside = CheckShapeInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectShape(obj);\r\n              else {\r\n                DeselectShape(obj);\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n      }\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n        }\r\n      }\r\n\r\n      // Call mouseDrag AFTER mouseMove\r\n      if (mouseDown) {\r\n        mouseDrag(e);\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse up\r\n    this.TOOLSELECT.onMouseUp = e => {\r\n      mouseDown = false;\r\n      var _return = false;\r\n\r\n      selectRectAnchor = null;\r\n      state.isSelecting = false;\r\n      selectRectPath.remove();\r\n\r\n      if (getSelection().length == 0) {\r\n        return;\r\n      }\r\n\r\n      if (state.isScaling) {\r\n        lockScaleX = false;\r\n        lockScaleY = false;\r\n\r\n        let bounds = getBounds(getSelection());\r\n\r\n        action.scale.data.handle_end = getOppositePoint(\r\n          point,\r\n          true,\r\n          true,\r\n          bounds\r\n        );\r\n        if (e.modifiers.shift) {\r\n          action.scale.data.shift = true;\r\n        }\r\n        this.ADD_ACTION(action.scale);\r\n\r\n        state.isScaling = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if (state.isDragging) {\r\n        action.move.data.endPos = e.point;\r\n        this.ADD_ACTION(action.move);\r\n\r\n        state.isDragging = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if(this.snappedX)\r\n        this.clearGuideLinesX();\r\n      if(this.snappedY)\r\n        this.clearGuideLinesY();\r\n\r\n      // Update transform box with new rectangle\r\n      hideTransformBox();\r\n      drawTransformBox(getBounds(getSelection()));\r\n\r\n      if (_return) {\r\n        return;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse drag\r\n    let mouseDrag = (e) => {\r\n      mouseDelta = e.point.subtract(_lastMousePos);\r\n      if(Data.SNAP_MOVE && state.isDragging) {\r\n        let snapY = null;\r\n        let snapX = null;\r\n\r\n        // Snapping y-axis\r\n        if(mouseDelta.y != 0) {\r\n          let snappedY = false;\r\n\r\n          // Check for top snap\r\n          let guided, _;\r\n          [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecTopY))\r\n          mouseDelta.y = guided.subtract(transformRect.bounds.topCenter).y;\r\n\r\n          if(snappedY) {\r\n            snapY = guided.y;\r\n          }\r\n          //If top hasn't snapped, check for bottom snap\r\n          else {\r\n            [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecBottomY));\r\n            mouseDelta.y = guided.subtract(transformRect.bounds.bottomCenter).y;\r\n\r\n            if(snappedY) {\r\n              snapY = guided.y;\r\n            }\r\n          }\r\n\r\n          // If snapped to a y-line, display the line\r\n          if (snapY != null) {\r\n            this.drawGuideLines(null, [snapY]);\r\n            this.snappedY = true;\r\n          }\r\n          else if(this.snappedY) {\r\n            this.snappedY = false;\r\n            this.clearGuideLinesY();\r\n          }\r\n        }\r\n\r\n        // Snapping x-axis\r\n        if(mouseDelta.x != 0) {\r\n          let snappedX = false;\r\n\r\n          // Check for left snap\r\n          let guided, _;\r\n          [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecLeftX));\r\n          mouseDelta.x = guided.subtract(transformRect.bounds.leftCenter).x;\r\n\r\n          if(snappedX) {\r\n            snapX = guided.x;\r\n          }\r\n          // If left hasn't snapped, check for right snap\r\n          else {\r\n            [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecRightX));\r\n            mouseDelta.x = guided.subtract(transformRect.bounds.rightCenter).x;\r\n\r\n            if(snappedX) {\r\n              snapX = guided.x;\r\n            }\r\n          }\r\n\r\n          // If snapped to a x-line, display the line\r\n          if (snapX != null) {\r\n            this.drawGuideLines([snapX], null);\r\n            this.snappedX = true;\r\n          }\r\n          else if(this.snappedX) {\r\n            this.snappedX = false;\r\n            this.clearGuideLinesX();\r\n          }\r\n        }\r\n      }\r\n\r\n      _lastMousePos = e.point;\r\n\r\n      var path = transformRect;\r\n\r\n      // User is moving the selection\r\n      if (state.isDragging) {\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(mouseDelta);\r\n        }\r\n\r\n        transformRect.translate(mouseDelta);\r\n        lastTransformRect = transformRect.bounds;\r\n\r\n        Object.keys(transformPoints).forEach(function(point, index) {\r\n          transformPoints[point].translate(mouseDelta);\r\n        });\r\n        return;\r\n      }\r\n\r\n      // User is scaling the selection\r\n      if (state.isScaling) {\r\n        // Add snapping if enabled\r\n        if(Data.SNAP_SCALE) {\r\n          if(Math.abs(transform.scale_facH) > 0.1 && Math.abs(transform.scale_facW) > 0.1) {\r\n            let [guided, xsnapped, ysnapped] = this.getGuidedPosition(e.point);\r\n            if (xsnapped) {\r\n              this.drawGuideLines([guided.x], null);\r\n              this.snappedX = true;\r\n            }\r\n            else if(this.snappedX) {\r\n              this.snappedX = false;\r\n              this.clearGuideLinesX();\r\n            }\r\n            if (ysnapped) {\r\n              this.drawGuideLines(null, [guided.y]);\r\n              this.snappedY = true;\r\n            }\r\n            else if(this.snappedY) {\r\n              this.snappedY = false;\r\n              this.clearGuideLinesY();\r\n            }\r\n\r\n            e.point = guided;\r\n          }\r\n        }\r\n        \r\n        let bounds = transformRect.bounds;\r\n\r\n        if (!lockScaleY) {\r\n          relH = e.point.subtract(point).y;\r\n          transform.scale_facH = Math.abs(relH) / bounds.height;\r\n        } else {\r\n          transform.scale_facH = 1;\r\n        }\r\n        if (!lockScaleX) {\r\n          relW = e.point.subtract(point).x;\r\n          transform.scale_facW = Math.abs(relW) / bounds.width;\r\n        } else {\r\n          transform.scale_facW = 1;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\r\n          return;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\r\n          return;\r\n        }\r\n\r\n        if (!e.modifiers.shift) {\r\n          checkScaleFlip();\r\n        }\r\n\r\n        if (e.modifiers.shift) {\r\n          var min = Math.min(\r\n            Math.abs(transform.scale_facH),\r\n            Math.abs(transform.scale_facW)\r\n          );\r\n\r\n          if (lockScaleY) {\r\n            min = Math.abs(transform.scale_facW);\r\n          } else if (lockScaleX) {\r\n            min = Math.abs(transform.scale_facH);\r\n          }\r\n\r\n          transform.scale_facH = min;\r\n          transform.scale_facW = min;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          if (!lockScaleX) {\r\n            transform.scale_facW *= 2;\r\n          }\r\n          if (!lockScaleY) {\r\n            transform.scale_facH *= 2;\r\n          }\r\n        }\r\n\r\n        // Scale all the selected items\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(\r\n            transform.scale_facW,\r\n            transform.scale_facH,\r\n            point\r\n          );\r\n        }\r\n\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        // Don't show the points while scaling\r\n        Object.keys(transformPoints).forEach((point, index) => {\r\n          transformPoints[point].remove();\r\n        });\r\n      }\r\n    }\r\n//\r\n\r\n//#region events\r\n    // - user is zooming -\r\n    bus.$on(\"zoom\", () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n      transformBoxSize = 7 / view.zoom;\r\n      transformBoxWidth = 2 / view.zoom;\r\n\r\n      if (getSelection().length > 0) {\r\n        updateTransformBox();\r\n      }\r\n    });\r\n\r\n    // - Ctrl + Z -\r\n    bus.$on(\"undo\", () => {\r\n      if (this.ACTIONS.length > 0) {\r\n        this.UNDO();\r\n\r\n        project.deselectAll();\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].selected = true;\r\n        }\r\n\r\n        updateTransformBox(getBounds(getSelection()));\r\n        this.updateGuidePoints();\r\n      }\r\n    });\r\n\r\n    // - delete key pressed -\r\n    bus.$on(\"delete_selection\", () => {\r\n      this.DESELECT();\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - shift key pressed -\r\n    bus.$on(\"shift\", () => {\r\n      if (state.isScaling) {\r\n        var bounds = getBounds(getSelection());\r\n\r\n        var facH_init = initTransfData.height / bounds.height;\r\n        var facW_init = initTransfData.width / bounds.width;\r\n\r\n        // Scale the selection to its initial size\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(facW_init, facH_init, point);\r\n        }\r\n\r\n        // Resize the transform rect as well\r\n        transformRect.scale(facW_init, facH_init, point);\r\n        var rel;\r\n\r\n        if (lockScaleX) {\r\n          rel = Math.abs(relH);\r\n        } else if (lockScaleY) {\r\n          rel = Math.abs(relW);\r\n        } else {\r\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\r\n        }\r\n\r\n        var fac = rel / Math.min(initTransfData.width, initTransfData.height);\r\n\r\n        // Resize the selection to the current size without deformation\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(fac, fac, point);\r\n        }\r\n\r\n        // Resize transform rect as well\r\n        transformRect.scale(fac, fac, point);\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    // - control key pressed -\r\n    bus.$on(\"control\", () => {\r\n      if (state.isScaling) {\r\n        handleControlKey();\r\n      }\r\n    });\r\n\r\n    // - control key released -\r\n    bus.$on(\"control_up\", () => {\r\n      if (state.isScaling) {\r\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\r\n        action.scale.data.pivot = point;\r\n\r\n        relH = mouseEvent.point.subtract(point).y;\r\n        relW = mouseEvent.point.subtract(point).x;\r\n\r\n        var curDistPt;\r\n\r\n        if (relH >= 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.topLeft;\r\n          flippedV = false;\r\n          flippedH = true;\r\n        } else if (relH >= 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.topRight;\r\n          flippedV = false;\r\n          flippedH = false;\r\n        } else if (relH < 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.bottomLeft;\r\n          flippedV = true;\r\n          flippedH = true;\r\n        } else if (relH < 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.bottomRight;\r\n          flippedV = true;\r\n          flippedH = false;\r\n        }\r\n\r\n        var delta = initTransfData.pivot.subtract(curDistPt);\r\n        if (lockScaleX) {\r\n          delta.x = 0;\r\n        } else if (lockScaleY) {\r\n          delta.y = 0;\r\n        }\r\n\r\n        transformRect.translate(delta);\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(delta);\r\n        }\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    bus.$on(\"hide-transformbox\", () => {\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - switched to another tool -\r\n    bus.$on(\"deactivate-select\", () => {\r\n      for (var i = 0; i < getSelection().length; i++) {\r\n        DeselectShape(getSelection());\r\n      }\r\n\r\n      if (this.ACTIVE_TOOL != \"pointer\") {\r\n        this.DESELECT();\r\n      }\r\n\r\n      hideTransformBox();\r\n    });\r\n\r\n    bus.$on(\"activate-select\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        for (var i = 0; i < getSelection().length; i++) {\r\n          SelectShape(getSelection()[i]);\r\n        }\r\n\r\n        // There could've been drawn a new shape\r\n        this.updateGuidePoints();\r\n\r\n        drawTransformBox(getBounds(getSelection()));\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_stroke\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_fill\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].fillColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_width_stroke\", width => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeWidth = width;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_cap_stroke\", type => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeCap = type;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_opacity\", opacity => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].opacity = opacity/100;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-hor\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(1, -1, center);\r\n        }\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-ver\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        for (var i = 0; i < this.SELECTED.length; i++) {\r\n          this.SELECTED[i].scale(-1, 1, center);\r\n        }\r\n      }\r\n    });\r\n\r\n    document.addEventListener(\"mousedown\", e => {\r\n      var temp = [];\r\n      for (var i = 0; i < this.ACTIONS.length; i++) {\r\n        temp.push(this.ACTIONS[i].data.paths.length);\r\n      }\r\n    });\r\n//\r\n\r\n//#region Aligning\r\n\r\n  // Horizontal\r\n  bus.$on('align-hor-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_x = Data.CENTER_HOR - bounds.center.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-hor-left', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docLeft = Data.CENTER_HOR - Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docLeft - bounds.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-hor-right', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docRight = Data.CENTER_HOR + Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docRight - (bounds.x + bounds.width);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n\r\n  // Vertical\r\n  bus.$on('align-ver-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_y = Data.CENTER_VER - bounds.center.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-ver-top', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER - Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - bounds.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-ver-bottom', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER + Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - (bounds.y + bounds.height);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n//\r\n  }\r\n};\r\n",{"version":3,"sources":["ToolSelect.vue"],"names":[],"mappings":";;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA","file":"ToolSelect.vue","sourceRoot":"src/components/tools","sourcesContent":["<template>\r\n  <tool imgSource=\"tool-select.png\" @isActive=\"setActive\" />\r\n</template>\r\n\r\n\r\n\r\n\r\n<script>\r\nimport paper from \"paper\";\r\nimport Tool from \"../Tool.vue\";\r\nimport { mapMutations, mapState } from \"vuex\";\r\nimport { bus, Action } from \"@/main.js\";\r\nimport Data from '@/Data.js';\r\nimport { GuideLines } from '@/mixins/GuideLines.js';\r\n\r\nexport default {\r\n  mixins: [GuideLines],\r\n  name: \"ToolSelect\",\r\n  data: function() {\r\n    return {\r\n      snappedY: false,\r\n      snappedX: false\r\n    }\r\n  },\r\n  computed: {\r\n    ...mapState([\r\n      \"ACTIVE_TOOL\", \r\n      \"TOOLSELECT\", \r\n      \"OBJECTS\", \r\n      \"SELECTED\", \r\n      \"ACTIONS\"\r\n      ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      \"SET_ACTIVE\",\r\n      \"ADD_SELECT\",\r\n      \"DESELECT\",\r\n      \"ADD_ACTION\",\r\n      \"UNDO\"\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\");\r\n\r\n      bus.$emit(\"activate-select\");\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n//#region Assigning\r\n    var el = document.querySelector(\"#tool-select\");\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var mouseEvent;\r\n\r\n    // Need this to create custom drag function\r\n    var mouseDown = false;\r\n\r\n    // Path over which the mouse currently hovers\r\n    let hoverItem;\r\n    var hoverSelection = new Path();\r\n    hoverSelection.selectable = false;\r\n\r\n    // Shadow paths while transforming path\r\n    let shadowPaths = [];\r\n\r\n    // Transform rectangle cache\r\n    var lastTransformRect;\r\n\r\n    // The selection rectangle with transform points\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      leftCenter: null,\r\n      rightCenter: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null,\r\n      bottomRight: null\r\n    };\r\n\r\n    // Updated through zoom\r\n    var transformBoxSize = 7 / view.zoom;\r\n    var transformBoxWidth = 2 / view.zoom;\r\n\r\n    // Object with transform information\r\n    var transform = {\r\n      // Scaling\r\n      pivot: null,\r\n      dir: \"\", // topLeft, topMiddle, ...\r\n\r\n      scale_facH: null,\r\n      scale_facW: null,\r\n    };\r\n\r\n    const state = {\r\n      isHovering: false,\r\n      isScaling: false,\r\n      isDragging: false,\r\n      isSelecting: false,\r\n      \r\n      snapVecLeftX: null,\r\n      snapVecRightX: null,\r\n      snapVecTopY: null,\r\n      snapVecBottomY: null\r\n    }\r\n\r\n    // The relative distances used in scaling\r\n    var relH;\r\n    var relW;\r\n\r\n    var selectRectAnchor = null;\r\n\r\n    // Selection rectangle\r\n    let selectRectPath = new Path();\r\n\r\n    var _lastMousePos;\r\n    var mouseDelta;\r\n\r\n    var flippedV = false;\r\n    var flippedH = false;\r\n    var lockScaleX = false;\r\n    var lockScaleY = false;\r\n    var point;\r\n\r\n    // Object containing the data before the scaling, used for undo and shift/control modifiers\r\n    var initTransfData = {\r\n      height: null,\r\n      width: null,\r\n      pivot: null,\r\n      center: null\r\n    };\r\n\r\n    var action = {\r\n      move: new Action(\"move\", {\r\n        startPos: null,\r\n        endPos: null,\r\n        paths: null\r\n      }),\r\n      scale: new Action(\"scale\", {\r\n        paths: null,\r\n        pivot: null,\r\n        handle_init: null,\r\n        handle_end: null,\r\n        lockX: false,\r\n        lockY: false,\r\n        shift: false\r\n      })\r\n    };\r\n//\r\n\r\n//#region Functions\r\n    let getSelection = () => {\r\n      return this.SELECTED;\r\n    }\r\n\r\n    let getUngrouped = (items) => {\r\n      if(items.length == 0) {\r\n        return [];\r\n      }\r\n\r\n      let result = [];\r\n\r\n      for(let i=0; i<items.length; i++) {\r\n        let item = items[i];\r\n\r\n        if(item.type == \"shape\")\r\n          result.push(item)\r\n        else if(item.type == \"group\") {\r\n          for(let j=0; j<item.children.length; j++) {\r\n            result.push(...getUngrouped([item.children[j]]));\r\n          }\r\n        }\r\n\r\n        // Error catching - prevent infinite loop\r\n        else {\r\n          console.error(\"Unknown item type! Item was: \" + item);\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function ResetHover() {\r\n      state.isHovering = false;\r\n\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        hoverSelection.remove();\r\n      }\r\n    }\r\n\r\n    function DrawHoverSelection(path) {\r\n      hoverSelection = path.clone();\r\n      Object.assign(hoverSelection, {\r\n        selectable: false,\r\n        strokeColor: \"#33b5ff\",\r\n        strokeWidth: 2 / paper.view.zoom\r\n      });\r\n    }\r\n\r\n    function DrawShadowPaths(paths) {\r\n      if(shadowPaths.length != 0) {\r\n        RemoveShadowPaths();\r\n      }\r\n\r\n      shadowPaths = [];\r\n      for(let i=0; i<paths.length; i++) {\r\n        let _path = paths[i].clone();\r\n        _path.selectable = false;\r\n        _path.selected = false;\r\n        _path.dashArray = [5, 5];\r\n        _path.opacity = 0.2;\r\n        shadowPaths.push(_path);\r\n      }\r\n    }\r\n\r\n    function RemoveShadowPaths() {\r\n      if(shadowPaths.length != 0) {\r\n        for(let i=0; i<shadowPaths.length; i++) {\r\n          shadowPaths[i].remove();\r\n        }\r\n        shadowPaths = [];\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverPath(item) {\r\n      if (!item.selected) {\r\n        DrawHoverSelection(item);\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverTransform(item) {\r\n      document.body.style.cursor = item.cursorType;\r\n      transform.pivot = item.opposite;\r\n    }\r\n\r\n    // Remove the selection box with transform points\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    // Draw selection box with transform points\r\n    function drawTransformBox(rect) {\r\n      if (rect) {\r\n        lastTransformRect = rect;\r\n      }\r\n\r\n      if (!lastTransformRect) return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(lastTransformRect);\r\n      transformRect.strokeColor = \"black\";\r\n      transformRect.selectable = false;\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n\r\n      // Calculate the positions\r\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize / 2);\r\n      var topMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n      var topRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var middleLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n      var middleRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var bottomLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\r\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\r\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\r\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\r\n\r\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\r\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize);\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\r\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n      // Set type\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].type = \"transformPoint\";\r\n        }\r\n      });\r\n\r\n      // Set cursor type\r\n      transformPoints.topLeft.cursorType = \"nw-resize\";\r\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\r\n\r\n      transformPoints.topMiddle.cursorType = \"n-resize\";\r\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\r\n\r\n      transformPoints.topRight.cursorType = \"ne-resize\";\r\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\r\n\r\n      transformPoints.leftCenter.cursorType = \"e-resize\";\r\n      transformPoints.rightCenter.cursorType = \"e-resize\";\r\n\r\n      // Set names\r\n      transformPoints.topLeft.name = \"topLeft\";\r\n      transformPoints.topRight.name = \"topRight\";\r\n      transformPoints.topMiddle.name = \"topCenter\";\r\n\r\n      transformPoints.leftCenter.name = \"leftCenter\";\r\n      transformPoints.rightCenter.name = \"rightCenter\";\r\n\r\n      transformPoints.bottomLeft.name = \"bottomLeft\";\r\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\r\n      transformPoints.bottomRight.name = \"bottomRight\";\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].selectable = false;\r\n          transformPoints[point].strokeColor = \"blue\";\r\n          transformPoints[point].fillColor = \"white\";\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n    // Redraw the selection box with transform points\r\n    function updateTransformBox(bounds) {\r\n      hideTransformBox();\r\n\r\n      if (bounds) {\r\n        drawTransformBox(bounds);\r\n      } else {\r\n        drawTransformBox();\r\n      }\r\n    }\r\n\r\n    // Hide the transform points, but keep the box (e.g. while moving selection)\r\n    function HideTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = false;\r\n      });\r\n    }\r\n\r\n    function ShowTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = true;\r\n      });\r\n    }\r\n\r\n    function CreateSelectionRectanglePath({rect, strokeWidth, strokeColor, dashArray}) {\r\n      let path = Path.Rectangle(rect);\r\n      Object.assign(path, {\r\n        strokeWidth: strokeWidth,\r\n        strokeColor: strokeColor,\r\n        dashArray: dashArray,\r\n        selectable: false\r\n      });\r\n      return path;\r\n    }\r\n\r\n  //#region Group\r\n    let SelectGroup = (group) => {\r\n      if(!group.selected) {\r\n        let ungrouped = getUngrouped([group]);\r\n        for(let i=0; i<ungrouped.length; i++) {\r\n          ungrouped[i].selected = true;\r\n        }\r\n        group.selected = true;\r\n        this.ADD_SELECT(group);\r\n      }\r\n    }\r\n\r\n    function DeselectGroup(group) {\r\n      DeselectShape(group);\r\n    }\r\n\r\n    function CheckGroupIntersection(group, rect) {\r\n      // Check for every child in the group\r\n      let children = getUngrouped(group.children);\r\n      for (let j = 0; j < children.length; j++) {\r\n        // Check for intersection with selection rect\r\n        if (rect.intersects(children[j])) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckGroupInsideRect(group, rect) {\r\n      let children = getUngrouped(group.children);\r\n      for(let i=0; i<children.length; i++) {\r\n        if (children[i].isInside(rect) && children[i].selectable) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n  //#region Shape\r\n    let SelectShape = (shape) => {\r\n      if (!shape.selected) {\r\n        shape.selected = true;\r\n        this.ADD_SELECT(shape);\r\n      }\r\n    }\r\n\r\n    let DeselectShape = (shape) => {\r\n      shape.selected = false;\r\n      let index = getSelection().findIndex(x => x === shape);\r\n      if (index != -1) {\r\n        getSelection().splice(index, 1);\r\n      }\r\n    }\r\n\r\n    function CheckShapeIntersection(shape, rectPath) {\r\n      // Selection rect intersects with the shape\r\n      if (rectPath.intersects(shape) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckShapeInsideRect(shape, rect) {\r\n      // Shape is inside the selection rect\r\n      if (shape.isInside(rect) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n    // Return the opposite point on the transform box\r\n    function getOppositePoint(point, x, y, bounds) {\r\n      if (!point) {\r\n        alert(\"warning: 001\");\r\n        return;\r\n      }\r\n      var _point = point;\r\n      var opposite = bounds.center.add(bounds.center.subtract(point));\r\n\r\n      if (x) {\r\n        _point = new Point(opposite.x, _point.y);\r\n      }\r\n      if (y) {\r\n        _point = new Point(_point.x, opposite.y);\r\n      }\r\n\r\n      return _point;\r\n    }\r\n\r\n    // Get the selection rectangle\r\n    let getBounds = (shapes) => {\r\n      if (shapes.length == 0) {\r\n        return null;\r\n      }\r\n\r\n      var _temp = [];\r\n      for (var i = 0; i < shapes.length; i++) {\r\n        let item = shapes[i];\r\n\r\n        if(item.type == \"group\") {\r\n          let ungrouped = getUngrouped(item.children);\r\n          for(let j=0; j<ungrouped.length; j++) {\r\n            _temp.push(ungrouped[j].clone());\r\n          }\r\n        }\r\n        else if(item.type == \"shape\") {\r\n          _temp.push(item.clone());\r\n        }\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      var rect = _grouped.bounds;\r\n      _grouped.remove();\r\n\r\n      return rect;\r\n    }\r\n\r\n    function RedrawTransformPoints() {\r\n      Object.keys(transformPoints).forEach((point, index) => {\r\n        transformPoints[point].position = transformRect.bounds[point];\r\n      });\r\n    }\r\n\r\n    // While scaling check whether the selection should be flipped\r\n    function checkScaleFlip() {\r\n      if (relH > 0 && flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = false;\r\n      } else if (relH < 0 && !flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = true;\r\n      }\r\n\r\n      if (relW > 0 && !flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = true;\r\n      }\r\n      if (relW < 0 && flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = false;\r\n      }\r\n    }\r\n\r\n    // Handle ctrl-key presses\r\n    function handleControlKey() {\r\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\r\n\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].translate(delta);\r\n      }\r\n\r\n      transformRect.position = initTransfData.center;\r\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\r\n\r\n      action.scale.data.pivot = point;\r\n\r\n      mouseDrag(mouseEvent);\r\n    }\r\n//\r\n\r\n//#region Mouse down\r\n    \r\n    this.TOOLSELECT.onMouseDown = e => {\r\n      mouseDown = true;\r\n      _lastMousePos = e.point;\r\n\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n          state.isDragging = true;\r\n\r\n          // Hide scaling points when moving the selection\r\n          HideTransformPoints();\r\n          DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n          state.snapVecLeftX = getBounds(getSelection()).leftCenter.subtract(e.point);\r\n          state.snapVecRightX = getBounds(getSelection()).rightCenter.subtract(e.point);\r\n          state.snapVecTopY = getBounds(getSelection()).topCenter.subtract(e.point);\r\n          state.snapVecBottomY = getBounds(getSelection()).bottomCenter.subtract(e.point);\r\n\r\n          action.move = new Action(\"move\", {\r\n            paths: getUngrouped(getSelection()),\r\n            startPos: e.point,\r\n            endPos: null\r\n          });\r\n\r\n          return;\r\n        }\r\n      }\r\n\r\n      hideTransformBox();\r\n      if (state.isHovering && hoverItem.type == \"transformPoint\") {\r\n        let bounds = getBounds(getSelection());\r\n\r\n        state.isScaling = true;\r\n\r\n        // Hide scaling points when scaling the selection\r\n        HideTransformPoints();\r\n        DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n        drawTransformBox();\r\n\r\n        transform.dir = e.item.name;\r\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds);\r\n\r\n        // Updating the backup data (for shift-scale and for undo)\r\n        initTransfData.width = bounds.width;\r\n        initTransfData.height = bounds.height;\r\n        initTransfData.pivot = new Point(point.x, point.y);\r\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\r\n\r\n        switch (transform.dir) {\r\n          case \"bottomLeft\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topLeft\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomRight\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topRight\":\r\n            flippedV = true;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topCenter\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"leftCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n          case \"rightCenter\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          handleControlKey();\r\n        }\r\n\r\n        action.scale = new Action(\"scale\", {\r\n          paths: getUngrouped(getSelection()),\r\n          pivot: initTransfData.pivot,\r\n          lockX: lockScaleX,\r\n          lockY: lockScaleY,\r\n          handle_init: bounds[transform.dir],\r\n          handle_end: null,\r\n          shift: false\r\n        });\r\n\r\n        mouseDrag(e);\r\n\r\n        return;\r\n      }\r\n\r\n      transformRect = new Path();\r\n\r\n      // Mouse is not over a shape\r\n      if (!state.isHovering) {\r\n        this.DESELECT();\r\n      }\r\n\r\n      // Mouse is over a shape\r\n      if (hoverSelection) {\r\n        hoverSelection.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\r\n          // Shift key is pressed\r\n          if (e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n\r\n            this.ADD_SELECT(hoverItem);\r\n          }\r\n          // Shift key is not pressed\r\n          else {\r\n            project.deselectAll();\r\n\r\n            this.DESELECT();\r\n\r\n            SelectShape(hoverItem);\r\n          }\r\n\r\n          drawTransformBox(getBounds(getSelection()));\r\n        }\r\n      }\r\n\r\n      if (!e.item) {\r\n        project.deselectAll();\r\n        this.DESELECT();\r\n        selectRectAnchor = e.point;\r\n        state.isSelecting = true;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse move\r\n    this.TOOLSELECT.onMouseMove = (e) => {\r\n      mouseEvent = e;\r\n\r\n      // Reset cursor style\r\n      document.body.style.cursor = \"default\";\r\n      ResetHover();\r\n\r\n      // Mouse is hovering over an item\r\n      if (e.item && !state.isSelecting && !state.isDragging) {\r\n\r\n        if (e.item.selectable) {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverPath(hoverItem);\r\n        }\r\n        \r\n        // Mouse is hovering over transform-handle (not selectable)\r\n        else if(e.item.type == \"transformPoint\") {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverTransform(hoverItem);\r\n        }\r\n      }\r\n\r\n      if (state.isSelecting && !state.isHovering) {\r\n        selectRectPath.remove();\r\n\r\n        let selectRect = new Rectangle(selectRectAnchor, e.point);\r\n\r\n        selectRectPath = CreateSelectionRectanglePath({\r\n          rect: selectRect,\r\n          strokeWidth: 0.5 / view.zoom,\r\n          strokeColor: \"black\",\r\n          dashArray: [4 / view.zoom, 3 / view.zoom]\r\n        });\r\n\r\n        let objects = this.OBJECTS;\r\n        for (let i = 0; i < objects.length; i++) {\r\n          /* First, check for intersections between the shapes and the selection rectangle,\r\n            if none, check whether the shapes are inside the rectangle */\r\n            \r\n          let obj = objects[i];\r\n\r\n          // Group\r\n          if (obj.type == \"group\" && obj.selectable) {\r\n            let _isIntersect = CheckGroupIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectGroup(obj);\r\n            else {\r\n              let _isInside = CheckGroupInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectGroup(obj);\r\n              else {\r\n                DeselectGroup(obj);\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Shape\r\n          else if (obj.type == \"shape\") {\r\n            let _isIntersect = CheckShapeIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectShape(obj);\r\n            else {\r\n              let _isInside = CheckShapeInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectShape(obj);\r\n              else {\r\n                DeselectShape(obj);\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n      }\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n        }\r\n      }\r\n\r\n      // Call mouseDrag AFTER mouseMove\r\n      if (mouseDown) {\r\n        mouseDrag(e);\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse up\r\n    this.TOOLSELECT.onMouseUp = e => {\r\n      mouseDown = false;\r\n      var _return = false;\r\n\r\n      selectRectAnchor = null;\r\n      state.isSelecting = false;\r\n      selectRectPath.remove();\r\n\r\n      if (getSelection().length == 0) {\r\n        return;\r\n      }\r\n\r\n      if (state.isScaling) {\r\n        lockScaleX = false;\r\n        lockScaleY = false;\r\n\r\n        let bounds = getBounds(getSelection());\r\n\r\n        action.scale.data.handle_end = getOppositePoint(\r\n          point,\r\n          true,\r\n          true,\r\n          bounds\r\n        );\r\n        if (e.modifiers.shift) {\r\n          action.scale.data.shift = true;\r\n        }\r\n        this.ADD_ACTION(action.scale);\r\n\r\n        state.isScaling = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if (state.isDragging) {\r\n        action.move.data.endPos = e.point;\r\n        this.ADD_ACTION(action.move);\r\n\r\n        state.isDragging = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if(this.snappedX)\r\n        this.clearGuideLinesX();\r\n      if(this.snappedY)\r\n        this.clearGuideLinesY();\r\n\r\n      // Update transform box with new rectangle\r\n      hideTransformBox();\r\n      drawTransformBox(getBounds(getSelection()));\r\n\r\n      if (_return) {\r\n        return;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse drag\r\n    let mouseDrag = (e) => {\r\n      mouseDelta = e.point.subtract(_lastMousePos);\r\n      if(Data.SNAP_MOVE && state.isDragging) {\r\n        let snapY = null;\r\n        let snapX = null;\r\n\r\n        // Snapping y-axis\r\n        if(mouseDelta.y != 0) {\r\n          let snappedY = false;\r\n\r\n          // Check for top snap\r\n          let guided, _;\r\n          [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecTopY))\r\n          mouseDelta.y = guided.subtract(transformRect.bounds.topCenter).y;\r\n\r\n          if(snappedY) {\r\n            snapY = guided.y;\r\n          }\r\n          //If top hasn't snapped, check for bottom snap\r\n          else {\r\n            [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecBottomY));\r\n            mouseDelta.y = guided.subtract(transformRect.bounds.bottomCenter).y;\r\n\r\n            if(snappedY) {\r\n              snapY = guided.y;\r\n            }\r\n          }\r\n\r\n          // If snapped to a y-line, display the line\r\n          if (snapY != null) {\r\n            this.drawGuideLines(null, [snapY]);\r\n            this.snappedY = true;\r\n          }\r\n          else if(this.snappedY) {\r\n            this.snappedY = false;\r\n            this.clearGuideLinesY();\r\n          }\r\n        }\r\n\r\n        // Snapping x-axis\r\n        if(mouseDelta.x != 0) {\r\n          let snappedX = false;\r\n\r\n          // Check for left snap\r\n          let guided, _;\r\n          [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecLeftX));\r\n          mouseDelta.x = guided.subtract(transformRect.bounds.leftCenter).x;\r\n\r\n          if(snappedX) {\r\n            snapX = guided.x;\r\n          }\r\n          // If left hasn't snapped, check for right snap\r\n          else {\r\n            [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecRightX));\r\n            mouseDelta.x = guided.subtract(transformRect.bounds.rightCenter).x;\r\n\r\n            if(snappedX) {\r\n              snapX = guided.x;\r\n            }\r\n          }\r\n\r\n          // If snapped to a x-line, display the line\r\n          if (snapX != null) {\r\n            this.drawGuideLines([snapX], null);\r\n            this.snappedX = true;\r\n          }\r\n          else if(this.snappedX) {\r\n            this.snappedX = false;\r\n            this.clearGuideLinesX();\r\n          }\r\n        }\r\n      }\r\n\r\n      _lastMousePos = e.point;\r\n\r\n      var path = transformRect;\r\n\r\n      // User is moving the selection\r\n      if (state.isDragging) {\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(mouseDelta);\r\n        }\r\n\r\n        transformRect.translate(mouseDelta);\r\n        lastTransformRect = transformRect.bounds;\r\n\r\n        Object.keys(transformPoints).forEach(function(point, index) {\r\n          transformPoints[point].translate(mouseDelta);\r\n        });\r\n        return;\r\n      }\r\n\r\n      // User is scaling the selection\r\n      if (state.isScaling) {\r\n        // Add snapping if enabled\r\n        if(Data.SNAP_SCALE) {\r\n          if(Math.abs(transform.scale_facH) > 0.1 && Math.abs(transform.scale_facW) > 0.1) {\r\n            let [guided, xsnapped, ysnapped] = this.getGuidedPosition(e.point);\r\n            if (xsnapped) {\r\n              this.drawGuideLines([guided.x], null);\r\n              this.snappedX = true;\r\n            }\r\n            else if(this.snappedX) {\r\n              this.snappedX = false;\r\n              this.clearGuideLinesX();\r\n            }\r\n            if (ysnapped) {\r\n              this.drawGuideLines(null, [guided.y]);\r\n              this.snappedY = true;\r\n            }\r\n            else if(this.snappedY) {\r\n              this.snappedY = false;\r\n              this.clearGuideLinesY();\r\n            }\r\n\r\n            e.point = guided;\r\n          }\r\n        }\r\n        \r\n        let bounds = transformRect.bounds;\r\n\r\n        if (!lockScaleY) {\r\n          relH = e.point.subtract(point).y;\r\n          transform.scale_facH = Math.abs(relH) / bounds.height;\r\n        } else {\r\n          transform.scale_facH = 1;\r\n        }\r\n        if (!lockScaleX) {\r\n          relW = e.point.subtract(point).x;\r\n          transform.scale_facW = Math.abs(relW) / bounds.width;\r\n        } else {\r\n          transform.scale_facW = 1;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\r\n          return;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\r\n          return;\r\n        }\r\n\r\n        if (!e.modifiers.shift) {\r\n          checkScaleFlip();\r\n        }\r\n\r\n        if (e.modifiers.shift) {\r\n          var min = Math.min(\r\n            Math.abs(transform.scale_facH),\r\n            Math.abs(transform.scale_facW)\r\n          );\r\n\r\n          if (lockScaleY) {\r\n            min = Math.abs(transform.scale_facW);\r\n          } else if (lockScaleX) {\r\n            min = Math.abs(transform.scale_facH);\r\n          }\r\n\r\n          transform.scale_facH = min;\r\n          transform.scale_facW = min;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          if (!lockScaleX) {\r\n            transform.scale_facW *= 2;\r\n          }\r\n          if (!lockScaleY) {\r\n            transform.scale_facH *= 2;\r\n          }\r\n        }\r\n\r\n        // Scale all the selected items\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(\r\n            transform.scale_facW,\r\n            transform.scale_facH,\r\n            point\r\n          );\r\n        }\r\n\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        // Don't show the points while scaling\r\n        Object.keys(transformPoints).forEach((point, index) => {\r\n          transformPoints[point].remove();\r\n        });\r\n      }\r\n    }\r\n//\r\n\r\n//#region events\r\n    // - user is zooming -\r\n    bus.$on(\"zoom\", () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n      transformBoxSize = 7 / view.zoom;\r\n      transformBoxWidth = 2 / view.zoom;\r\n\r\n      if (getSelection().length > 0) {\r\n        updateTransformBox();\r\n      }\r\n    });\r\n\r\n    // - Ctrl + Z -\r\n    bus.$on(\"undo\", () => {\r\n      if (this.ACTIONS.length > 0) {\r\n        this.UNDO();\r\n\r\n        project.deselectAll();\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].selected = true;\r\n        }\r\n\r\n        updateTransformBox(getBounds(getSelection()));\r\n        this.updateGuidePoints();\r\n      }\r\n    });\r\n\r\n    // - delete key pressed -\r\n    bus.$on(\"delete_selection\", () => {\r\n      this.DESELECT();\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - shift key pressed -\r\n    bus.$on(\"shift\", () => {\r\n      if (state.isScaling) {\r\n        var bounds = getBounds(getSelection());\r\n\r\n        var facH_init = initTransfData.height / bounds.height;\r\n        var facW_init = initTransfData.width / bounds.width;\r\n\r\n        // Scale the selection to its initial size\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(facW_init, facH_init, point);\r\n        }\r\n\r\n        // Resize the transform rect as well\r\n        transformRect.scale(facW_init, facH_init, point);\r\n        var rel;\r\n\r\n        if (lockScaleX) {\r\n          rel = Math.abs(relH);\r\n        } else if (lockScaleY) {\r\n          rel = Math.abs(relW);\r\n        } else {\r\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\r\n        }\r\n\r\n        var fac = rel / Math.min(initTransfData.width, initTransfData.height);\r\n\r\n        // Resize the selection to the current size without deformation\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(fac, fac, point);\r\n        }\r\n\r\n        // Resize transform rect as well\r\n        transformRect.scale(fac, fac, point);\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    // - control key pressed -\r\n    bus.$on(\"control\", () => {\r\n      if (state.isScaling) {\r\n        handleControlKey();\r\n      }\r\n    });\r\n\r\n    // - control key released -\r\n    bus.$on(\"control_up\", () => {\r\n      if (state.isScaling) {\r\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\r\n        action.scale.data.pivot = point;\r\n\r\n        relH = mouseEvent.point.subtract(point).y;\r\n        relW = mouseEvent.point.subtract(point).x;\r\n\r\n        var curDistPt;\r\n\r\n        if (relH >= 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.topLeft;\r\n          flippedV = false;\r\n          flippedH = true;\r\n        } else if (relH >= 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.topRight;\r\n          flippedV = false;\r\n          flippedH = false;\r\n        } else if (relH < 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.bottomLeft;\r\n          flippedV = true;\r\n          flippedH = true;\r\n        } else if (relH < 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.bottomRight;\r\n          flippedV = true;\r\n          flippedH = false;\r\n        }\r\n\r\n        var delta = initTransfData.pivot.subtract(curDistPt);\r\n        if (lockScaleX) {\r\n          delta.x = 0;\r\n        } else if (lockScaleY) {\r\n          delta.y = 0;\r\n        }\r\n\r\n        transformRect.translate(delta);\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(delta);\r\n        }\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    bus.$on(\"hide-transformbox\", () => {\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - switched to another tool -\r\n    bus.$on(\"deactivate-select\", () => {\r\n      for (var i = 0; i < getSelection().length; i++) {\r\n        DeselectShape(getSelection());\r\n      }\r\n\r\n      if (this.ACTIVE_TOOL != \"pointer\") {\r\n        this.DESELECT();\r\n      }\r\n\r\n      hideTransformBox();\r\n    });\r\n\r\n    bus.$on(\"activate-select\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        for (var i = 0; i < getSelection().length; i++) {\r\n          SelectShape(getSelection()[i]);\r\n        }\r\n\r\n        // There could've been drawn a new shape\r\n        this.updateGuidePoints();\r\n\r\n        drawTransformBox(getBounds(getSelection()));\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_stroke\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_fill\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].fillColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_width_stroke\", width => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeWidth = width;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_cap_stroke\", type => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeCap = type;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_opacity\", opacity => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].opacity = opacity/100;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-hor\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(1, -1, center);\r\n        }\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-ver\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        for (var i = 0; i < this.SELECTED.length; i++) {\r\n          this.SELECTED[i].scale(-1, 1, center);\r\n        }\r\n      }\r\n    });\r\n\r\n    document.addEventListener(\"mousedown\", e => {\r\n      var temp = [];\r\n      for (var i = 0; i < this.ACTIONS.length; i++) {\r\n        temp.push(this.ACTIONS[i].data.paths.length);\r\n      }\r\n    });\r\n//\r\n\r\n//#region Aligning\r\n\r\n  // Horizontal\r\n  bus.$on('align-hor-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_x = Data.CENTER_HOR - bounds.center.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-hor-left', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docLeft = Data.CENTER_HOR - Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docLeft - bounds.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-hor-right', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docRight = Data.CENTER_HOR + Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docRight - (bounds.x + bounds.width);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n\r\n  // Vertical\r\n  bus.$on('align-ver-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_y = Data.CENTER_VER - bounds.center.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-ver-top', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER - Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - bounds.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n\r\n  bus.$on('align-ver-bottom', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER + Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - (bounds.y + bounds.height);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n  });\r\n//\r\n  }\r\n};\r\n</script>\r\n\r\n\r\n\r\n\r\n\r\n<style scoped>\r\n</style>"]}]}