{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue","mtime":1554757000689},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n\r\nimport paper from 'paper'\r\nimport Tool from '../Tool.vue'\r\nimport { mapMutations, mapState } from 'vuex'\r\nimport { bus } from '@/main.js'\r\n\r\nexport default {\r\n  name: 'ToolSelect',\r\n  computed: {\r\n    ...mapState([\r\n      'ACTIVE',\r\n      'TOOLSELECT',\r\n      'OBJECTS'\r\n    ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      'SET_ACTIVE',\r\n      'ADD_SHAPE',\r\n      'ADD_SELECT',\r\n      'CLEAR_SELECT'\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\")\r\n\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n    var self = this;\r\n\r\n    var el = document.querySelector('#tool-select');\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var hoverItem;\r\n    var selectionPath;\r\n\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      middleLeft: null,\r\n      middleRight: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null, \r\n      bottomRight: null\r\n    }\r\n    // Updated through zoom\r\n    var transformBoxSize = 7/view.zoom;\r\n    var transformBoxWidth = 2/view.zoom;\r\n\r\n    var selectingPoint = null;\r\n    var selectRect = new Path();\r\n\r\n    var localSelect = [];\r\n\r\n    bus.$on('delete_selection', () => {\r\n      hideTransformBox();\r\n    });\r\n\r\n    bus.$on('zoom', () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n      transformBoxSize = 7/view.zoom;\r\n      transformBoxWidth = 2/view.zoom;\r\n\r\n      updateTransformBox();\r\n    });\r\n\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    var _lastTransformRect;\r\n    function drawTransformBox(rect) {\r\n      if(rect) {\r\n        _lastTransformRect = rect;\r\n      }\r\n\r\n      if(!_lastTransformRect)\r\n        return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(_lastTransformRect);\r\n      transformRect.strokeColor = 'black';\r\n      transformRect.locked = true;\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(_lastTransformRect.point.subtract(transformBoxSize/2), transformBoxSize);\r\n      var topMiddleRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width/2, _lastTransformRect.point.y).subtract(transformBoxSize/2), transformBoxSize);\r\n      var topRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y).subtract(transformBoxSize/2), transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(new Point(_lastTransformRect.point.x, _lastTransformRect.point.y + _lastTransformRect.height/2).subtract(transformBoxSize/2), transformBoxSize);\r\n      var middleRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y + _lastTransformRect.height/2).subtract(transformBoxSize/2), transformBoxSize);\r\n      \r\n      var bottomLeftRect = new Rectangle(new Point(_lastTransformRect.point.x, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width/2, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n      var bottomRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.middleLeft = Path.Rectangle(middleLeftRect);\r\n      transformPoints.middleRight = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].locked = true;\r\n          transformPoints[point].strokeColor = 'blue';\r\n          transformPoints[point].fillColor = 'white';\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n    function updateTransformBox() {\r\n      hideTransformBox();\r\n      drawTransformBox();\r\n    }\r\n\r\n    self.TOOLSELECT.onMouseDown = function(e) {\r\n      localSelect = [];\r\n      hideTransformBox();\r\n\r\n      transformRect = new Path();\r\n\r\n      if(selectionPath) {\r\n        selectionPath.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected) {\r\n          if(e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n            self.ADD_SELECT(hoverItem);\r\n          }\r\n          else {\r\n            project.activeLayer.selected = false;\r\n            hoverItem.selected = true;\r\n            self.CLEAR_SELECT();\r\n            self.ADD_SELECT(hoverItem);\r\n          }\r\n        }\r\n      }\r\n      \r\n      if(!e.item) {\r\n        project.activeLayer.selected = false;\r\n        self.CLEAR_SELECT();\r\n        selectingPoint = e.point;\r\n      }\r\n    }\r\n\r\n    self.TOOLSELECT.onMouseMove = function(e) {\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        selectionPath.remove();\r\n      }\r\n\r\n      if (e.item) {\r\n        hoverItem = e.item;\r\n        selectionPath = hoverItem.clone();\r\n        selectionPath.strokeColor = '#33b5ff';\r\n        selectionPath.strokeWidth = 2 / paper.view.zoom;\r\n      }\r\n\r\n      if(selectingPoint) {\r\n        selectRect.remove();\r\n        selectRect = Path.Rectangle(selectingPoint, e.point);\r\n        selectRect.locked = true;\r\n        selectRect.dashArray = [4/view.zoom, 3/view.zoom];\r\n        selectRect.strokeColor = 'black';\r\n        selectRect.strokeWidth = 0.5/view.zoom;\r\n\r\n        for(var i=0; i < self.OBJECTS.length; i++) {\r\n          if(selectRect.intersects(self.OBJECTS[i])) {\r\n            if(!self.OBJECTS[i].selected) {\r\n              self.OBJECTS[i].selected = true;\r\n              localSelect.push(self.OBJECTS[i]);\r\n            }\r\n          }\r\n          else {\r\n            var _selRect = new Rectangle(selectingPoint, e.point)\r\n            if(self.OBJECTS[i].isInside(_selRect)) {\r\n              if(!self.OBJECTS[i].selected) {\r\n                self.OBJECTS[i].selected = true;\r\n                localSelect.push(self.OBJECTS[i]);\r\n              }\r\n            }\r\n            else {\r\n              self.OBJECTS[i].selected = false;\r\n              var index = localSelect.findIndex(x => x === self.OBJECTS[i]);\r\n              if(index != -1) {\r\n                localSelect.splice(index, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    self.TOOLSELECT.onMouseUp = function(e) {\r\n      selectingPoint = null;\r\n      selectRect.remove();\r\n\r\n      var _temp = [];\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        _temp.push(localSelect[i].clone());\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      drawTransformBox(_grouped.bounds);\r\n      _grouped.remove();\r\n\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        self.ADD_SELECT(localSelect[i]);\r\n      }\r\n    }\r\n  }\r\n}\r\n",{"version":3,"sources":["ToolSelect.vue"],"names":[],"mappings":";;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"ToolSelect.vue","sourceRoot":"src/components/tools","sourcesContent":["<template>\r\n  <tool imgSource=\"tool-select.png\" @isActive=\"setActive\" />  \r\n</template>\r\n\r\n\r\n\r\n\r\n\r\n<script>\r\nimport paper from 'paper'\r\nimport Tool from '../Tool.vue'\r\nimport { mapMutations, mapState } from 'vuex'\r\nimport { bus } from '@/main.js'\r\n\r\nexport default {\r\n  name: 'ToolSelect',\r\n  computed: {\r\n    ...mapState([\r\n      'ACTIVE',\r\n      'TOOLSELECT',\r\n      'OBJECTS'\r\n    ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      'SET_ACTIVE',\r\n      'ADD_SHAPE',\r\n      'ADD_SELECT',\r\n      'CLEAR_SELECT'\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\")\r\n\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n    var self = this;\r\n\r\n    var el = document.querySelector('#tool-select');\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var hoverItem;\r\n    var selectionPath;\r\n\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      middleLeft: null,\r\n      middleRight: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null, \r\n      bottomRight: null\r\n    }\r\n    // Updated through zoom\r\n    var transformBoxSize = 7/view.zoom;\r\n    var transformBoxWidth = 2/view.zoom;\r\n\r\n    var selectingPoint = null;\r\n    var selectRect = new Path();\r\n\r\n    var localSelect = [];\r\n\r\n    bus.$on('delete_selection', () => {\r\n      hideTransformBox();\r\n    });\r\n\r\n    bus.$on('zoom', () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n      transformBoxSize = 7/view.zoom;\r\n      transformBoxWidth = 2/view.zoom;\r\n\r\n      updateTransformBox();\r\n    });\r\n\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    var _lastTransformRect;\r\n    function drawTransformBox(rect) {\r\n      if(rect) {\r\n        _lastTransformRect = rect;\r\n      }\r\n\r\n      if(!_lastTransformRect)\r\n        return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(_lastTransformRect);\r\n      transformRect.strokeColor = 'black';\r\n      transformRect.locked = true;\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(_lastTransformRect.point.subtract(transformBoxSize/2), transformBoxSize);\r\n      var topMiddleRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width/2, _lastTransformRect.point.y).subtract(transformBoxSize/2), transformBoxSize);\r\n      var topRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y).subtract(transformBoxSize/2), transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(new Point(_lastTransformRect.point.x, _lastTransformRect.point.y + _lastTransformRect.height/2).subtract(transformBoxSize/2), transformBoxSize);\r\n      var middleRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y + _lastTransformRect.height/2).subtract(transformBoxSize/2), transformBoxSize);\r\n      \r\n      var bottomLeftRect = new Rectangle(new Point(_lastTransformRect.point.x, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width/2, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n      var bottomRightRect = new Rectangle(new Point(_lastTransformRect.point.x + _lastTransformRect.width, _lastTransformRect.point.y + _lastTransformRect.height).subtract(transformBoxSize/2), transformBoxSize);\r\n\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.middleLeft = Path.Rectangle(middleLeftRect);\r\n      transformPoints.middleRight = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].locked = true;\r\n          transformPoints[point].strokeColor = 'blue';\r\n          transformPoints[point].fillColor = 'white';\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n    function updateTransformBox() {\r\n      hideTransformBox();\r\n      drawTransformBox();\r\n    }\r\n\r\n    self.TOOLSELECT.onMouseDown = function(e) {\r\n      localSelect = [];\r\n      hideTransformBox();\r\n\r\n      transformRect = new Path();\r\n\r\n      if(selectionPath) {\r\n        selectionPath.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected) {\r\n          if(e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n            self.ADD_SELECT(hoverItem);\r\n          }\r\n          else {\r\n            project.activeLayer.selected = false;\r\n            hoverItem.selected = true;\r\n            self.CLEAR_SELECT();\r\n            self.ADD_SELECT(hoverItem);\r\n          }\r\n        }\r\n      }\r\n      \r\n      if(!e.item) {\r\n        project.activeLayer.selected = false;\r\n        self.CLEAR_SELECT();\r\n        selectingPoint = e.point;\r\n      }\r\n    }\r\n\r\n    self.TOOLSELECT.onMouseMove = function(e) {\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        selectionPath.remove();\r\n      }\r\n\r\n      if (e.item) {\r\n        hoverItem = e.item;\r\n        selectionPath = hoverItem.clone();\r\n        selectionPath.strokeColor = '#33b5ff';\r\n        selectionPath.strokeWidth = 2 / paper.view.zoom;\r\n      }\r\n\r\n      if(selectingPoint) {\r\n        selectRect.remove();\r\n        selectRect = Path.Rectangle(selectingPoint, e.point);\r\n        selectRect.locked = true;\r\n        selectRect.dashArray = [4/view.zoom, 3/view.zoom];\r\n        selectRect.strokeColor = 'black';\r\n        selectRect.strokeWidth = 0.5/view.zoom;\r\n\r\n        for(var i=0; i < self.OBJECTS.length; i++) {\r\n          if(selectRect.intersects(self.OBJECTS[i])) {\r\n            if(!self.OBJECTS[i].selected) {\r\n              self.OBJECTS[i].selected = true;\r\n              localSelect.push(self.OBJECTS[i]);\r\n            }\r\n          }\r\n          else {\r\n            var _selRect = new Rectangle(selectingPoint, e.point)\r\n            if(self.OBJECTS[i].isInside(_selRect)) {\r\n              if(!self.OBJECTS[i].selected) {\r\n                self.OBJECTS[i].selected = true;\r\n                localSelect.push(self.OBJECTS[i]);\r\n              }\r\n            }\r\n            else {\r\n              self.OBJECTS[i].selected = false;\r\n              var index = localSelect.findIndex(x => x === self.OBJECTS[i]);\r\n              if(index != -1) {\r\n                localSelect.splice(index, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    self.TOOLSELECT.onMouseUp = function(e) {\r\n      selectingPoint = null;\r\n      selectRect.remove();\r\n\r\n      var _temp = [];\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        _temp.push(localSelect[i].clone());\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      drawTransformBox(_grouped.bounds);\r\n      _grouped.remove();\r\n\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        self.ADD_SELECT(localSelect[i]);\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n\r\n\r\n\r\n\r\n<style scoped>\r\n</style>"]}]}