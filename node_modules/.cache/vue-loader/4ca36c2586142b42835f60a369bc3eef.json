{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue","mtime":1555157746872},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n\r\nimport paper from 'paper'\r\nimport Tool from '../Tool.vue'\r\nimport { mapMutations, mapState } from 'vuex'\r\nimport { bus, Action } from '@/main.js'\r\n\r\nexport default {\r\n  name: 'ToolSelect',\r\n  computed: {\r\n    ...mapState([\r\n      'ACTIVE',\r\n      'TOOLSELECT',\r\n      'OBJECTS',\r\n      'SELECTED',\r\n      'ACTIONS'\r\n    ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      'SET_ACTIVE',\r\n      'ADD_SHAPE',\r\n      'ADD_SELECT',\r\n      'CLEAR_SELECT',\r\n      'DELETE_SELECT',\r\n      'ADD_ACTION',\r\n      'UNDO'\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\")\r\n\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n    var self = this;\r\n\r\n    var el = document.querySelector('#tool-select');\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var mousePos;\r\n\r\n    // Need this to create custom drag function\r\n    var mouseDown = false;\r\n\r\n    // Path over which the mouse currently hovers\r\n    var hoverItem;\r\n    var hoverSelection = new Path();\r\n    hoverSelection.selectable = false;\r\n\r\n    // Transform rectangle cache\r\n    var lastTransformRect;\r\n\r\n    // The selection rectangle with transform points\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      leftCenter: null,\r\n      rightCenter: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null, \r\n      bottomRight: null\r\n    }\r\n\r\n    // Updated through zoom\r\n    var transformBoxSize = 7/view.zoom;\r\n    var transformBoxWidth = 2/view.zoom;\r\n\r\n    // Object with transform information\r\n    var transform = {\r\n      hover: false,\r\n      scaling: false,\r\n      pivot: null,\r\n      dir: '', // topLeft, topMiddle, ...\r\n\r\n      scale_facH: null,\r\n      scale_facW: null\r\n    };\r\n\r\n    // The relative distances used in scaling\r\n    var relH;\r\n    var relW;\r\n\r\n    var selectingPoint = null;\r\n    var selectRectPath = new Path();\r\n\r\n    // Local array containing the selected paths (self.SELECTED is the public array)\r\n    var localSelect = [];\r\n\r\n\r\n\r\n    var _lastMousePos;\r\n    var mouseDelta;\r\n\r\n\r\n\r\n    var flippedV = false;\r\n    var flippedH = false;\r\n    var lockScaleX = false;\r\n    var lockScaleY = false;\r\n    var point;\r\n\r\n    var selectRect;\r\n\r\n    // Object containing the data before the scaling, useful for undo and shift/control modifiers\r\n    var initTransfData = {\r\n      height: null,\r\n      width: null,\r\n      pivot: null,\r\n      center: null\r\n    }\r\n\r\n    var action = {\r\n      move: new Action('move', {\r\n        startPos: null,\r\n        endPos: null,\r\n        paths: null,\r\n      }),\r\n      scale: new Action('scale', {\r\n        paths: null,\r\n        pivot: null,\r\n        handle_init: null,\r\n        handle_end: null,\r\n        lockX: false,\r\n        lockY: false\r\n      })\r\n    }\r\n\r\n\r\n\r\n    // Remove the selection box with transform points\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    // Draw selection box with transform points\r\n    function drawTransformBox(rect) {\r\n      if(rect) {\r\n        lastTransformRect = rect;\r\n      }\r\n\r\n      if(!lastTransformRect)\r\n        return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(lastTransformRect);\r\n      transformRect.strokeColor = 'black';\r\n      transformRect.selectable = false;\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n\r\n      // Calculate the positions\r\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize/2);\r\n      var topMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width/2, lastTransformRect.point.y).subtract(transformBoxSize/2);\r\n      var topRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y).subtract(transformBoxSize/2);\r\n\r\n      var middleLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height/2).subtract(transformBoxSize/2);\r\n      var middleRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height/2).subtract(transformBoxSize/2);\r\n\r\n      var bottomLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n      var bottomMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width/2, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n      var bottomRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\r\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\r\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\r\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\r\n      \r\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\r\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize);\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\r\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n      // Set type\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].type = 'transformPoint';\r\n        }\r\n      });\r\n\r\n      // Set cursor type\r\n      transformPoints.topLeft.cursorType = \"nw-resize\";\r\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\r\n\r\n      transformPoints.topMiddle.cursorType = \"n-resize\";\r\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\r\n\r\n      transformPoints.topRight.cursorType = \"ne-resize\";\r\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\r\n\r\n      transformPoints.leftCenter.cursorType = \"e-resize\";\r\n      transformPoints.rightCenter.cursorType = \"e-resize\";\r\n\r\n      // Set names\r\n      transformPoints.topLeft.name = \"topLeft\";\r\n      transformPoints.topRight.name = \"topRight\";\r\n      transformPoints.topMiddle.name = \"topCenter\";\r\n\r\n      transformPoints.leftCenter.name = \"leftCenter\";\r\n      transformPoints.rightCenter.name = \"rightCenter\";\r\n\r\n      transformPoints.bottomLeft.name = \"bottomLeft\";\r\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\r\n      transformPoints.bottomRight.name = \"bottomRight\";\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].selectable = false;\r\n          transformPoints[point].strokeColor = 'blue';\r\n          transformPoints[point].fillColor = 'white';\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    // Redraw the selection box with transform points\r\n    function updateTransformBox(bounds) {\r\n      hideTransformBox();\r\n\r\n      if(bounds) {\r\n        drawTransformBox(bounds);\r\n      }\r\n      else {\r\n        drawTransformBox();\r\n      }\r\n    }\r\n\r\n\r\n    // Return the opposite point on the transform box\r\n    function getOppositePoint(point, x, y, bounds) {\r\n      if(!point) {\r\n        alert(\"warning: 001\");\r\n        return;\r\n      }\r\n      var _point = point;\r\n      var opposite = bounds.center.add(bounds.center.subtract(point));\r\n\r\n      if(x) {\r\n        _point = new Point(opposite.x, _point.y);\r\n      }\r\n      if(y) {\r\n        _point = new Point(_point.x, opposite.y);\r\n      }\r\n\r\n      return _point;\r\n    }\r\n\r\n\r\n    // Get the selection rectangle\r\n    function getBounds() {\r\n      if(localSelect.length == 0)\r\n        return;\r\n\r\n      var _temp = [];\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        _temp.push(localSelect[i].clone());\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      var rect = _grouped.bounds;\r\n      _grouped.remove();\r\n\r\n      return rect;\r\n    }\r\n\r\n\r\n    function RedrawTransformPoints() {\r\n      Object.keys(transformPoints).forEach((point, index) => {\r\n        transformPoints[point].position = transformRect.bounds[point];\r\n      });\r\n    }\r\n\r\n\r\n    // While scaling check whether the selection should be flipped\r\n    function checkScaleFlip() {\r\n      if(relH > 0 && flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH\r\n        flippedV = false\r\n      }\r\n      else if(relH < 0 && !flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH\r\n        flippedV = true\r\n      }\r\n      \r\n      if(relW > 0 && !flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW\r\n        flippedH = true\r\n      }\r\n      if(relW < 0 && flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW\r\n        flippedH = false\r\n      }\r\n    }\r\n\r\n\r\n    // Handle ctrl-key presses\r\n    function handleControlKey() {\r\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\r\n\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        localSelect[i].translate(delta);\r\n      }\r\n\r\n      transformRect.position = initTransfData.center;\r\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\r\n\r\n      action.scale.data.pivot = point;\r\n\r\n      mouseDrag(mousePos);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // - Mouse down -\r\n    self.TOOLSELECT.onMouseDown = function(e) {\r\n      mouseDown = true;\r\n      _lastMousePos = e.point;\r\n\r\n      if(transform.dragging) {\r\n        action.move = new Action('move', {\r\n          paths: localSelect,\r\n          startPos: e.point,\r\n          endPos: null\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      hideTransformBox();\r\n      if(transform.hover) {\r\n        var bounds = getBounds();\r\n\r\n        transform.scaling = true;\r\n\r\n        drawTransformBox();\r\n\r\n        transform.dir = e.item.name;\r\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds);\r\n\r\n        // Updating the backup data (for shift-scale and for undo)\r\n        initTransfData.width = bounds.width;\r\n        initTransfData.height = bounds.height;\r\n        initTransfData.pivot = new Point(point.x, point.y);\r\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\r\n\r\n        switch(transform.dir) {\r\n          case 'bottomLeft':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topLeft':\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'bottomRight':\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topRight':\r\n            flippedV = true;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'bottomCenter':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topCenter':\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'leftCenter':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n          case 'rightCenter':\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n        }\r\n\r\n\r\n        if (e.modifiers.control) {\r\n          handleControlKey();\r\n        }\r\n\r\n        action.scale = new Action('scale', {\r\n          paths: localSelect,\r\n          pivot: initTransfData.pivot,\r\n          lockX: lockScaleX,\r\n          lockY: lockScaleY,\r\n          handle_init: bounds[transform.dir],\r\n          handle_end: null\r\n        })\r\n\r\n        mouseDrag(e);\r\n\r\n        return;\r\n      }\r\n      \r\n      transformRect = new Path();\r\n\r\n      // Mouse is not over a shape\r\n      if(!hoverItem) {\r\n        localSelect = [];\r\n      }\r\n\r\n      if(hoverSelection) {\r\n        hoverSelection.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\r\n          // Shift key is pressed\r\n          if(e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n\r\n            self.ADD_SELECT(hoverItem);\r\n            localSelect.push(hoverItem);\r\n          }\r\n          // Shift key is not pressed\r\n          else {\r\n            project.activeLayer.selected = false;\r\n            hoverItem.selected = true;\r\n\r\n            localSelect = [];\r\n            self.CLEAR_SELECT();\r\n\r\n            self.ADD_SELECT(hoverItem);\r\n            localSelect.push(hoverItem);\r\n          }\r\n\r\n          drawTransformBox(getBounds());\r\n        }\r\n      }\r\n      \r\n      if(!e.item) {\r\n        project.activeLayer.selected = false;\r\n        self.CLEAR_SELECT();\r\n        selectingPoint = e.point;\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse move -\r\n    self.TOOLSELECT.onMouseMove = function(e) {\r\n      mousePos = e;\r\n\r\n      if (mouseDown) {\r\n        mouseDrag(e);\r\n      }\r\n\r\n      document.body.style.cursor = \"default\";\r\n      transform.hover = false;\r\n\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        hoverSelection.remove();\r\n      }\r\n\r\n      if (e.item) {\r\n        hoverItem = e.item;\r\n\r\n        if(hoverItem.selectable && !hoverItem.selected) {\r\n          hoverSelection = hoverItem.clone();\r\n          hoverSelection.strokeColor = '#33b5ff';\r\n          hoverSelection.strokeWidth = 2 / paper.view.zoom;\r\n\r\n          hoverSelection.selectable = false;\r\n        }\r\n        else {\r\n          if(hoverItem.type == 'transformPoint') {\r\n            document.body.style.cursor = hoverItem.cursorType;\r\n\r\n            transform.hover = true;\r\n            transform.pivot = hoverItem.opposite;\r\n          }\r\n        }\r\n      }\r\n\r\n      if(selectingPoint && !transform.hover) {\r\n        selectRectPath.remove();\r\n\r\n        selectRect = new Rectangle(selectingPoint, e.point);\r\n\r\n        selectRectPath = Path.Rectangle(selectRect);\r\n        selectRectPath.selectable = false;\r\n        selectRectPath.dashArray = [4/view.zoom, 3/view.zoom];\r\n        selectRectPath.strokeColor = 'black';\r\n        selectRectPath.strokeWidth = 0.5/view.zoom;\r\n\r\n        var _selRect = new Rectangle(selectingPoint, e.point);\r\n\r\n        for(var i=0; i < self.OBJECTS.length; i++) {\r\n          // Selection rect intersects with the shape\r\n          if(selectRectPath.intersects(self.OBJECTS[i])) {\r\n            if(!self.OBJECTS[i].selected) {\r\n              self.OBJECTS[i].selected = true;\r\n              localSelect.push(self.OBJECTS[i]);\r\n            }\r\n          }\r\n          // Selection rect doesn't intersect with shape\r\n          else {\r\n            // Shape is inside the selection rect\r\n            if(self.OBJECTS[i].isInside(_selRect)) {\r\n              if(!self.OBJECTS[i].selected) {\r\n                self.OBJECTS[i].selected = true;\r\n                localSelect.push(self.OBJECTS[i]);\r\n              }\r\n            }\r\n\r\n            // Shape is not inside the selection rect\r\n            else {\r\n              self.OBJECTS[i].selected = false;\r\n              var index = localSelect.findIndex(x => x === self.OBJECTS[i]);\r\n              if(index != -1) {\r\n                localSelect.splice(index, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      transform.dragging = false;\r\n\r\n      if(self.SELECTED.length != 0) {\r\n        if(e.point.isInside(lastTransformRect) && !transform.hover && !transform.scaling) {\r\n          document.body.style.cursor = \"move\";\r\n          transform.dragging = true;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse up -\r\n    self.TOOLSELECT.onMouseUp = function(e) {\r\n      mouseDown = false;\r\n      var _return = false;\r\n      \r\n      selectingPoint = null;\r\n      selectRectPath.remove();\r\n\r\n      if(localSelect.length == 0) {\r\n        return;\r\n      }\r\n\r\n      if(transform.scaling) {\r\n        lockScaleX = false;\r\n        lockScaleY = false;\r\n\r\n        var bounds = getBounds();\r\n        \r\n        action.scale.data.handle_end = getOppositePoint(point, true, true, transformRect.bounds);;\r\n        self.ADD_ACTION(action.scale);\r\n\r\n        transform.scaling = false;\r\n        _return = true;\r\n      }\r\n\r\n      if(transform.dragging) {\r\n        action.move.data.endPos = e.point;\r\n        self.ADD_ACTION(action.move);\r\n\r\n        transform.dragging = false;\r\n        _return = true;\r\n      }\r\n\r\n      // Update transform box with new rectangle\r\n      hideTransformBox();\r\n      drawTransformBox(getBounds());\r\n\r\n      if(_return) {\r\n        return;\r\n      }\r\n\r\n      self.CLEAR_SELECT();\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        self.ADD_SELECT(localSelect[i]);\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse drag -\r\n    function mouseDrag(e) {\r\n      mouseDelta = e.point.subtract(_lastMousePos);\r\n      _lastMousePos = e.point;\r\n\r\n      var path = transformRect;\r\n\r\n      // User is moving the selection\r\n      if(transform.dragging) {\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].translate(mouseDelta);\r\n        }\r\n\r\n        transformRect.translate(mouseDelta);\r\n        lastTransformRect = transformRect.bounds;\r\n\r\n        Object.keys(transformPoints).forEach(function(point, index) {\r\n          transformPoints[point].translate(mouseDelta);\r\n      });\r\n        return;\r\n      }\r\n\r\n      // User is scaling the selection\r\n      if(transform.scaling) {\r\n        var bounds = transformRect.bounds;\r\n\r\n        if(!lockScaleY) {\r\n          relH = e.point.subtract(point).y;\r\n          transform.scale_facH = Math.abs(relH)/bounds.height;\r\n        }\r\n        else {\r\n          transform.scale_facH = 1;\r\n        }\r\n        if(!lockScaleX) {\r\n          relW = e.point.subtract(point).x;\r\n          transform.scale_facW = Math.abs(relW)/bounds.width;\r\n        }\r\n        else {\r\n          transform.scale_facW = 1;\r\n        }\r\n        \r\n        if(Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\r\n            return;\r\n        }\r\n\r\n        if(Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\r\n          return;\r\n        }\r\n\r\n        if(!e.modifiers.shift) {\r\n          checkScaleFlip();\r\n        }\r\n\r\n        if(e.modifiers.shift) {\r\n          var min = Math.min(Math.abs(transform.scale_facH), Math.abs(transform.scale_facW));\r\n\r\n          if(lockScaleY) {\r\n            min = Math.abs(transform.scale_facW);\r\n          }\r\n          else if(lockScaleX) {\r\n            min = Math.abs(transform.scale_facH);\r\n          }\r\n\r\n          transform.scale_facH = min;\r\n          transform.scale_facW = min;\r\n        }\r\n\r\n        if(e.modifiers.control) {\r\n          if(!lockScaleX) {\r\n            transform.scale_facW *= 2;\r\n          }\r\n          if(!lockScaleY) {\r\n            transform.scale_facH *= 2;\r\n          }\r\n        }\r\n\r\n        // Scale all the selected items\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(transform.scale_facW, transform.scale_facH, point)\r\n        }\r\n\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        // Don't show the points while scaling\r\n        Object.keys(transformPoints).forEach((point, index) => {\r\n          transformPoints[point].remove();\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - user is zooming -\r\n    bus.$on('zoom', () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n      transformBoxSize = 7/view.zoom;\r\n      transformBoxWidth = 2/view.zoom;\r\n\r\n      if(localSelect.length > 0) {\r\n        updateTransformBox();\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - Ctrl + Z -\r\n    bus.$on('undo', () => {\r\n      if(self.ACTIONS.length > 0) {\r\n        self.UNDO();\r\n\r\n        localSelect = [...self.SELECTED];\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].selected = true;\r\n        }\r\n\r\n        updateTransformBox(getBounds());\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - delete key pressed -\r\n    bus.$on('delete_selection', () => {\r\n      localSelect = [];\r\n      hideTransformBox();\r\n    });\r\n\r\n\r\n\r\n    // - shift key pressed -\r\n    bus.$on('shift', () => {\r\n      if(transform.scaling) {\r\n        var bounds = getBounds();\r\n\r\n        var facH_init = initTransfData.height/bounds.height;\r\n        var facW_init = initTransfData.width/bounds.width;\r\n\r\n        // Scale the selection to its initial size\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(facW_init, facH_init, point);\r\n        }\r\n\r\n        // Resize the transform rect as well\r\n        transformRect.scale(facW_init, facH_init, point);\r\n        var rel;\r\n\r\n        if(lockScaleX) {\r\n          rel = Math.abs(relH);\r\n        }\r\n        else if(lockScaleY) {\r\n          rel = Math.abs(relW);\r\n        }\r\n        else {\r\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\r\n        }\r\n\r\n        var fac = rel/Math.min(initTransfData.width, initTransfData.height);\r\n\r\n        // Resize the selection to the current size without deformation\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(fac, fac, point);\r\n        }\r\n\r\n        // Resize transform rect as well\r\n        transformRect.scale(fac, fac, point);\r\n\r\n        mouseDrag(mousePos);\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - control key pressed -\r\n    bus.$on('control', () => {\r\n      if(transform.scaling) {\r\n        handleControlKey();\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - control key released -\r\n    bus.$on('control_up', () => {\r\n      if(transform.scaling) {\r\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\r\n        action.scale.data.pivot = point;\r\n\r\n        var bounds = transformRect.bounds;\r\n\r\n        relH = mousePos.point.subtract(point).y;\r\n        relW = mousePos.point.subtract(point).x;\r\n\r\n        var curDistPt;\r\n\r\n        if (relH >= 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.topLeft;\r\n          flippedV = false;\r\n          flippedH = true;\r\n        }\r\n        else if(relH >= 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.topRight;\r\n          flippedV = false;\r\n          flippedH = false;\r\n        }\r\n        else if(relH < 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.bottomLeft;\r\n          flippedV = true;\r\n          flippedH = true;\r\n        }\r\n        else if(relH < 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.bottomRight;\r\n          flippedV = true;\r\n          flippedH = false;\r\n        }\r\n\r\n        var delta = initTransfData.pivot.subtract(curDistPt);\r\n        if(lockScaleX) {\r\n          delta.x = 0;\r\n        }\r\n        else if(lockScaleY) {\r\n          delta.y = 0;\r\n        }\r\n\r\n        transformRect.translate(delta);\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].translate(delta);\r\n        }\r\n\r\n        mouseDrag(mousePos);\r\n      }\r\n    });\r\n  }\r\n}\r\n",{"version":3,"sources":["ToolSelect.vue"],"names":[],"mappings":";;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"ToolSelect.vue","sourceRoot":"src/components/tools","sourcesContent":["<template>\r\n  <tool imgSource=\"tool-select.png\" @isActive=\"setActive\" />  \r\n</template>\r\n\r\n\r\n\r\n\r\n\r\n<script>\r\nimport paper from 'paper'\r\nimport Tool from '../Tool.vue'\r\nimport { mapMutations, mapState } from 'vuex'\r\nimport { bus, Action } from '@/main.js'\r\n\r\nexport default {\r\n  name: 'ToolSelect',\r\n  computed: {\r\n    ...mapState([\r\n      'ACTIVE',\r\n      'TOOLSELECT',\r\n      'OBJECTS',\r\n      'SELECTED',\r\n      'ACTIONS'\r\n    ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      'SET_ACTIVE',\r\n      'ADD_SHAPE',\r\n      'ADD_SELECT',\r\n      'CLEAR_SELECT',\r\n      'DELETE_SELECT',\r\n      'ADD_ACTION',\r\n      'UNDO'\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\")\r\n\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n    var self = this;\r\n\r\n    var el = document.querySelector('#tool-select');\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var mousePos;\r\n\r\n    // Need this to create custom drag function\r\n    var mouseDown = false;\r\n\r\n    // Path over which the mouse currently hovers\r\n    var hoverItem;\r\n    var hoverSelection = new Path();\r\n    hoverSelection.selectable = false;\r\n\r\n    // Transform rectangle cache\r\n    var lastTransformRect;\r\n\r\n    // The selection rectangle with transform points\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      leftCenter: null,\r\n      rightCenter: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null, \r\n      bottomRight: null\r\n    }\r\n\r\n    // Updated through zoom\r\n    var transformBoxSize = 7/view.zoom;\r\n    var transformBoxWidth = 2/view.zoom;\r\n\r\n    // Object with transform information\r\n    var transform = {\r\n      hover: false,\r\n      scaling: false,\r\n      pivot: null,\r\n      dir: '', // topLeft, topMiddle, ...\r\n\r\n      scale_facH: null,\r\n      scale_facW: null\r\n    };\r\n\r\n    // The relative distances used in scaling\r\n    var relH;\r\n    var relW;\r\n\r\n    var selectingPoint = null;\r\n    var selectRectPath = new Path();\r\n\r\n    // Local array containing the selected paths (self.SELECTED is the public array)\r\n    var localSelect = [];\r\n\r\n\r\n\r\n    var _lastMousePos;\r\n    var mouseDelta;\r\n\r\n\r\n\r\n    var flippedV = false;\r\n    var flippedH = false;\r\n    var lockScaleX = false;\r\n    var lockScaleY = false;\r\n    var point;\r\n\r\n    var selectRect;\r\n\r\n    // Object containing the data before the scaling, useful for undo and shift/control modifiers\r\n    var initTransfData = {\r\n      height: null,\r\n      width: null,\r\n      pivot: null,\r\n      center: null\r\n    }\r\n\r\n    var action = {\r\n      move: new Action('move', {\r\n        startPos: null,\r\n        endPos: null,\r\n        paths: null,\r\n      }),\r\n      scale: new Action('scale', {\r\n        paths: null,\r\n        pivot: null,\r\n        handle_init: null,\r\n        handle_end: null,\r\n        lockX: false,\r\n        lockY: false\r\n      })\r\n    }\r\n\r\n\r\n\r\n    // Remove the selection box with transform points\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    // Draw selection box with transform points\r\n    function drawTransformBox(rect) {\r\n      if(rect) {\r\n        lastTransformRect = rect;\r\n      }\r\n\r\n      if(!lastTransformRect)\r\n        return;\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(lastTransformRect);\r\n      transformRect.strokeColor = 'black';\r\n      transformRect.selectable = false;\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n\r\n      // Calculate the positions\r\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize/2);\r\n      var topMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width/2, lastTransformRect.point.y).subtract(transformBoxSize/2);\r\n      var topRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y).subtract(transformBoxSize/2);\r\n\r\n      var middleLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height/2).subtract(transformBoxSize/2);\r\n      var middleRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height/2).subtract(transformBoxSize/2);\r\n\r\n      var bottomLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n      var bottomMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width/2, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n      var bottomRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize/2);\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\r\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\r\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\r\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\r\n      \r\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\r\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize);\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\r\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n      // Set type\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].type = 'transformPoint';\r\n        }\r\n      });\r\n\r\n      // Set cursor type\r\n      transformPoints.topLeft.cursorType = \"nw-resize\";\r\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\r\n\r\n      transformPoints.topMiddle.cursorType = \"n-resize\";\r\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\r\n\r\n      transformPoints.topRight.cursorType = \"ne-resize\";\r\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\r\n\r\n      transformPoints.leftCenter.cursorType = \"e-resize\";\r\n      transformPoints.rightCenter.cursorType = \"e-resize\";\r\n\r\n      // Set names\r\n      transformPoints.topLeft.name = \"topLeft\";\r\n      transformPoints.topRight.name = \"topRight\";\r\n      transformPoints.topMiddle.name = \"topCenter\";\r\n\r\n      transformPoints.leftCenter.name = \"leftCenter\";\r\n      transformPoints.rightCenter.name = \"rightCenter\";\r\n\r\n      transformPoints.bottomLeft.name = \"bottomLeft\";\r\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\r\n      transformPoints.bottomRight.name = \"bottomRight\";\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if(transformPoints[point]) {\r\n          transformPoints[point].selectable = false;\r\n          transformPoints[point].strokeColor = 'blue';\r\n          transformPoints[point].fillColor = 'white';\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    // Redraw the selection box with transform points\r\n    function updateTransformBox(bounds) {\r\n      hideTransformBox();\r\n\r\n      if(bounds) {\r\n        drawTransformBox(bounds);\r\n      }\r\n      else {\r\n        drawTransformBox();\r\n      }\r\n    }\r\n\r\n\r\n    // Return the opposite point on the transform box\r\n    function getOppositePoint(point, x, y, bounds) {\r\n      if(!point) {\r\n        alert(\"warning: 001\");\r\n        return;\r\n      }\r\n      var _point = point;\r\n      var opposite = bounds.center.add(bounds.center.subtract(point));\r\n\r\n      if(x) {\r\n        _point = new Point(opposite.x, _point.y);\r\n      }\r\n      if(y) {\r\n        _point = new Point(_point.x, opposite.y);\r\n      }\r\n\r\n      return _point;\r\n    }\r\n\r\n\r\n    // Get the selection rectangle\r\n    function getBounds() {\r\n      if(localSelect.length == 0)\r\n        return;\r\n\r\n      var _temp = [];\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        _temp.push(localSelect[i].clone());\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      var rect = _grouped.bounds;\r\n      _grouped.remove();\r\n\r\n      return rect;\r\n    }\r\n\r\n\r\n    function RedrawTransformPoints() {\r\n      Object.keys(transformPoints).forEach((point, index) => {\r\n        transformPoints[point].position = transformRect.bounds[point];\r\n      });\r\n    }\r\n\r\n\r\n    // While scaling check whether the selection should be flipped\r\n    function checkScaleFlip() {\r\n      if(relH > 0 && flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH\r\n        flippedV = false\r\n      }\r\n      else if(relH < 0 && !flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH\r\n        flippedV = true\r\n      }\r\n      \r\n      if(relW > 0 && !flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW\r\n        flippedH = true\r\n      }\r\n      if(relW < 0 && flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW\r\n        flippedH = false\r\n      }\r\n    }\r\n\r\n\r\n    // Handle ctrl-key presses\r\n    function handleControlKey() {\r\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\r\n\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        localSelect[i].translate(delta);\r\n      }\r\n\r\n      transformRect.position = initTransfData.center;\r\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\r\n\r\n      action.scale.data.pivot = point;\r\n\r\n      mouseDrag(mousePos);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // - Mouse down -\r\n    self.TOOLSELECT.onMouseDown = function(e) {\r\n      mouseDown = true;\r\n      _lastMousePos = e.point;\r\n\r\n      if(transform.dragging) {\r\n        action.move = new Action('move', {\r\n          paths: localSelect,\r\n          startPos: e.point,\r\n          endPos: null\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      hideTransformBox();\r\n      if(transform.hover) {\r\n        var bounds = getBounds();\r\n\r\n        transform.scaling = true;\r\n\r\n        drawTransformBox();\r\n\r\n        transform.dir = e.item.name;\r\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds);\r\n\r\n        // Updating the backup data (for shift-scale and for undo)\r\n        initTransfData.width = bounds.width;\r\n        initTransfData.height = bounds.height;\r\n        initTransfData.pivot = new Point(point.x, point.y);\r\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\r\n\r\n        switch(transform.dir) {\r\n          case 'bottomLeft':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topLeft':\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'bottomRight':\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topRight':\r\n            flippedV = true;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'bottomCenter':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'topCenter':\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case 'leftCenter':\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n          case 'rightCenter':\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n        }\r\n\r\n\r\n        if (e.modifiers.control) {\r\n          handleControlKey();\r\n        }\r\n\r\n        action.scale = new Action('scale', {\r\n          paths: localSelect,\r\n          pivot: initTransfData.pivot,\r\n          lockX: lockScaleX,\r\n          lockY: lockScaleY,\r\n          handle_init: bounds[transform.dir],\r\n          handle_end: null\r\n        })\r\n\r\n        mouseDrag(e);\r\n\r\n        return;\r\n      }\r\n      \r\n      transformRect = new Path();\r\n\r\n      // Mouse is not over a shape\r\n      if(!hoverItem) {\r\n        localSelect = [];\r\n      }\r\n\r\n      if(hoverSelection) {\r\n        hoverSelection.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\r\n          // Shift key is pressed\r\n          if(e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n\r\n            self.ADD_SELECT(hoverItem);\r\n            localSelect.push(hoverItem);\r\n          }\r\n          // Shift key is not pressed\r\n          else {\r\n            project.activeLayer.selected = false;\r\n            hoverItem.selected = true;\r\n\r\n            localSelect = [];\r\n            self.CLEAR_SELECT();\r\n\r\n            self.ADD_SELECT(hoverItem);\r\n            localSelect.push(hoverItem);\r\n          }\r\n\r\n          drawTransformBox(getBounds());\r\n        }\r\n      }\r\n      \r\n      if(!e.item) {\r\n        project.activeLayer.selected = false;\r\n        self.CLEAR_SELECT();\r\n        selectingPoint = e.point;\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse move -\r\n    self.TOOLSELECT.onMouseMove = function(e) {\r\n      mousePos = e;\r\n\r\n      if (mouseDown) {\r\n        mouseDrag(e);\r\n      }\r\n\r\n      document.body.style.cursor = \"default\";\r\n      transform.hover = false;\r\n\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        hoverSelection.remove();\r\n      }\r\n\r\n      if (e.item) {\r\n        hoverItem = e.item;\r\n\r\n        if(hoverItem.selectable && !hoverItem.selected) {\r\n          hoverSelection = hoverItem.clone();\r\n          hoverSelection.strokeColor = '#33b5ff';\r\n          hoverSelection.strokeWidth = 2 / paper.view.zoom;\r\n\r\n          hoverSelection.selectable = false;\r\n        }\r\n        else {\r\n          if(hoverItem.type == 'transformPoint') {\r\n            document.body.style.cursor = hoverItem.cursorType;\r\n\r\n            transform.hover = true;\r\n            transform.pivot = hoverItem.opposite;\r\n          }\r\n        }\r\n      }\r\n\r\n      if(selectingPoint && !transform.hover) {\r\n        selectRectPath.remove();\r\n\r\n        selectRect = new Rectangle(selectingPoint, e.point);\r\n\r\n        selectRectPath = Path.Rectangle(selectRect);\r\n        selectRectPath.selectable = false;\r\n        selectRectPath.dashArray = [4/view.zoom, 3/view.zoom];\r\n        selectRectPath.strokeColor = 'black';\r\n        selectRectPath.strokeWidth = 0.5/view.zoom;\r\n\r\n        var _selRect = new Rectangle(selectingPoint, e.point);\r\n\r\n        for(var i=0; i < self.OBJECTS.length; i++) {\r\n          // Selection rect intersects with the shape\r\n          if(selectRectPath.intersects(self.OBJECTS[i])) {\r\n            if(!self.OBJECTS[i].selected) {\r\n              self.OBJECTS[i].selected = true;\r\n              localSelect.push(self.OBJECTS[i]);\r\n            }\r\n          }\r\n          // Selection rect doesn't intersect with shape\r\n          else {\r\n            // Shape is inside the selection rect\r\n            if(self.OBJECTS[i].isInside(_selRect)) {\r\n              if(!self.OBJECTS[i].selected) {\r\n                self.OBJECTS[i].selected = true;\r\n                localSelect.push(self.OBJECTS[i]);\r\n              }\r\n            }\r\n\r\n            // Shape is not inside the selection rect\r\n            else {\r\n              self.OBJECTS[i].selected = false;\r\n              var index = localSelect.findIndex(x => x === self.OBJECTS[i]);\r\n              if(index != -1) {\r\n                localSelect.splice(index, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      transform.dragging = false;\r\n\r\n      if(self.SELECTED.length != 0) {\r\n        if(e.point.isInside(lastTransformRect) && !transform.hover && !transform.scaling) {\r\n          document.body.style.cursor = \"move\";\r\n          transform.dragging = true;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse up -\r\n    self.TOOLSELECT.onMouseUp = function(e) {\r\n      mouseDown = false;\r\n      var _return = false;\r\n      \r\n      selectingPoint = null;\r\n      selectRectPath.remove();\r\n\r\n      if(localSelect.length == 0) {\r\n        return;\r\n      }\r\n\r\n      if(transform.scaling) {\r\n        lockScaleX = false;\r\n        lockScaleY = false;\r\n\r\n        var bounds = getBounds();\r\n        \r\n        action.scale.data.handle_end = getOppositePoint(point, true, true, transformRect.bounds);;\r\n        self.ADD_ACTION(action.scale);\r\n\r\n        transform.scaling = false;\r\n        _return = true;\r\n      }\r\n\r\n      if(transform.dragging) {\r\n        action.move.data.endPos = e.point;\r\n        self.ADD_ACTION(action.move);\r\n\r\n        transform.dragging = false;\r\n        _return = true;\r\n      }\r\n\r\n      // Update transform box with new rectangle\r\n      hideTransformBox();\r\n      drawTransformBox(getBounds());\r\n\r\n      if(_return) {\r\n        return;\r\n      }\r\n\r\n      self.CLEAR_SELECT();\r\n      for(var i=0; i<localSelect.length; i++) {\r\n        self.ADD_SELECT(localSelect[i]);\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - Mouse drag -\r\n    function mouseDrag(e) {\r\n      mouseDelta = e.point.subtract(_lastMousePos);\r\n      _lastMousePos = e.point;\r\n\r\n      var path = transformRect;\r\n\r\n      // User is moving the selection\r\n      if(transform.dragging) {\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].translate(mouseDelta);\r\n        }\r\n\r\n        transformRect.translate(mouseDelta);\r\n        lastTransformRect = transformRect.bounds;\r\n\r\n        Object.keys(transformPoints).forEach(function(point, index) {\r\n          transformPoints[point].translate(mouseDelta);\r\n      });\r\n        return;\r\n      }\r\n\r\n      // User is scaling the selection\r\n      if(transform.scaling) {\r\n        var bounds = transformRect.bounds;\r\n\r\n        if(!lockScaleY) {\r\n          relH = e.point.subtract(point).y;\r\n          transform.scale_facH = Math.abs(relH)/bounds.height;\r\n        }\r\n        else {\r\n          transform.scale_facH = 1;\r\n        }\r\n        if(!lockScaleX) {\r\n          relW = e.point.subtract(point).x;\r\n          transform.scale_facW = Math.abs(relW)/bounds.width;\r\n        }\r\n        else {\r\n          transform.scale_facW = 1;\r\n        }\r\n        \r\n        if(Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\r\n            return;\r\n        }\r\n\r\n        if(Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\r\n          return;\r\n        }\r\n\r\n        if(!e.modifiers.shift) {\r\n          checkScaleFlip();\r\n        }\r\n\r\n        if(e.modifiers.shift) {\r\n          var min = Math.min(Math.abs(transform.scale_facH), Math.abs(transform.scale_facW));\r\n\r\n          if(lockScaleY) {\r\n            min = Math.abs(transform.scale_facW);\r\n          }\r\n          else if(lockScaleX) {\r\n            min = Math.abs(transform.scale_facH);\r\n          }\r\n\r\n          transform.scale_facH = min;\r\n          transform.scale_facW = min;\r\n        }\r\n\r\n        if(e.modifiers.control) {\r\n          if(!lockScaleX) {\r\n            transform.scale_facW *= 2;\r\n          }\r\n          if(!lockScaleY) {\r\n            transform.scale_facH *= 2;\r\n          }\r\n        }\r\n\r\n        // Scale all the selected items\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(transform.scale_facW, transform.scale_facH, point)\r\n        }\r\n\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        // Don't show the points while scaling\r\n        Object.keys(transformPoints).forEach((point, index) => {\r\n          transformPoints[point].remove();\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n\r\n    // - user is zooming -\r\n    bus.$on('zoom', () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5/view.zoom;\r\n      transformBoxSize = 7/view.zoom;\r\n      transformBoxWidth = 2/view.zoom;\r\n\r\n      if(localSelect.length > 0) {\r\n        updateTransformBox();\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - Ctrl + Z -\r\n    bus.$on('undo', () => {\r\n      if(self.ACTIONS.length > 0) {\r\n        self.UNDO();\r\n\r\n        localSelect = [...self.SELECTED];\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].selected = true;\r\n        }\r\n\r\n        updateTransformBox(getBounds());\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - delete key pressed -\r\n    bus.$on('delete_selection', () => {\r\n      localSelect = [];\r\n      hideTransformBox();\r\n    });\r\n\r\n\r\n\r\n    // - shift key pressed -\r\n    bus.$on('shift', () => {\r\n      if(transform.scaling) {\r\n        var bounds = getBounds();\r\n\r\n        var facH_init = initTransfData.height/bounds.height;\r\n        var facW_init = initTransfData.width/bounds.width;\r\n\r\n        // Scale the selection to its initial size\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(facW_init, facH_init, point);\r\n        }\r\n\r\n        // Resize the transform rect as well\r\n        transformRect.scale(facW_init, facH_init, point);\r\n        var rel;\r\n\r\n        if(lockScaleX) {\r\n          rel = Math.abs(relH);\r\n        }\r\n        else if(lockScaleY) {\r\n          rel = Math.abs(relW);\r\n        }\r\n        else {\r\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\r\n        }\r\n\r\n        var fac = rel/Math.min(initTransfData.width, initTransfData.height);\r\n\r\n        // Resize the selection to the current size without deformation\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].scale(fac, fac, point);\r\n        }\r\n\r\n        // Resize transform rect as well\r\n        transformRect.scale(fac, fac, point);\r\n\r\n        mouseDrag(mousePos);\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - control key pressed -\r\n    bus.$on('control', () => {\r\n      if(transform.scaling) {\r\n        handleControlKey();\r\n      }\r\n    });\r\n\r\n\r\n\r\n    // - control key released -\r\n    bus.$on('control_up', () => {\r\n      if(transform.scaling) {\r\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\r\n        action.scale.data.pivot = point;\r\n\r\n        var bounds = transformRect.bounds;\r\n\r\n        relH = mousePos.point.subtract(point).y;\r\n        relW = mousePos.point.subtract(point).x;\r\n\r\n        var curDistPt;\r\n\r\n        if (relH >= 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.topLeft;\r\n          flippedV = false;\r\n          flippedH = true;\r\n        }\r\n        else if(relH >= 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.topRight;\r\n          flippedV = false;\r\n          flippedH = false;\r\n        }\r\n        else if(relH < 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.bottomLeft;\r\n          flippedV = true;\r\n          flippedH = true;\r\n        }\r\n        else if(relH < 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.bottomRight;\r\n          flippedV = true;\r\n          flippedH = false;\r\n        }\r\n\r\n        var delta = initTransfData.pivot.subtract(curDistPt);\r\n        if(lockScaleX) {\r\n          delta.x = 0;\r\n        }\r\n        else if(lockScaleY) {\r\n          delta.y = 0;\r\n        }\r\n\r\n        transformRect.translate(delta);\r\n        for(var i=0; i<localSelect.length; i++) {\r\n          localSelect[i].translate(delta);\r\n        }\r\n\r\n        mouseDrag(mousePos);\r\n      }\r\n    });\r\n  }\r\n}\r\n</script>\r\n\r\n\r\n\r\n\r\n\r\n<style scoped>\r\n</style>"]}]}