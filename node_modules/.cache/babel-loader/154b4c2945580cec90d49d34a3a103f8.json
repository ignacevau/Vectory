{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js!D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js","mtime":1579277066731},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _objectSpread from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\nimport { mapState, mapMutations } from \"vuex\";\nimport Utils from '@/Utils.js';\nimport paper from \"paper\";\nimport Data from '@/Data.js';\nexport var GuideLines = {\n  computed: _objectSpread({}, mapState(['OBJECTS', 'GUIDE_X_VALUES', 'GUIDE_Y_VALUES', 'SCREEN_BORDER'])),\n  methods: _objectSpread({}, mapMutations(['SET_GUIDE_X_VALUES', 'SET_GUIDE_Y_VALUES', 'CLEAR_GUIDE_LINES_X', 'CLEAR_GUIDE_LINES_Y', 'ADD_GUIDE_LINES_X', 'ADD_GUIDE_LINES_Y']), {\n    updateGuidePoints: function updateGuidePoints() {\n      var objects = Utils.getUngrouped(this.OBJECTS);\n      var x_values = [];\n      var y_values = [];\n\n      for (var i = 0; i < objects.length; i++) {\n        var item = objects[i];\n        x_values.push(item.bounds.center.x);\n        x_values.push(item.bounds.leftCenter.x);\n        x_values.push(item.bounds.rightCenter.x);\n        y_values.push(item.bounds.center.y);\n        y_values.push(item.bounds.topCenter.y);\n        y_values.push(item.bounds.bottomCenter.y);\n      }\n\n      this.SET_GUIDE_X_VALUES(x_values);\n      this.SET_GUIDE_Y_VALUES(y_values);\n    },\n    clearGuideLinesX: function clearGuideLinesX() {\n      this.CLEAR_GUIDE_LINES_X();\n    },\n    clearGuideLinesY: function clearGuideLinesY() {\n      this.CLEAR_GUIDE_LINES_Y();\n    },\n    drawGuideLines: function drawGuideLines() {\n      var x_values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y_values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (x_values == null && y_values == null) {\n        x_values = this.GUIDE_X_VALUES;\n        y_values = this.GUIDE_Y_VALUES;\n      }\n\n      if (x_values != null) {\n        this.CLEAR_GUIDE_LINES_X();\n\n        for (var i = 0; i < x_values.length; i++) {\n          // Vertical line\n          var ver_p1 = new Point(x_values[i], this.SCREEN_BORDER.bounds.bottomCenter.y);\n          var ver_p2 = new Point(x_values[i], this.SCREEN_BORDER.bounds.topCenter.y);\n          var verGL = new Path.Line(ver_p1, ver_p2);\n          verGL.strokeColor = 'red';\n          verGL.strokeWidth = 0.5;\n          this.ADD_GUIDE_LINES_X([verGL]);\n        }\n      }\n\n      if (y_values != null) {\n        this.CLEAR_GUIDE_LINES_Y();\n\n        for (var _i = 0; _i < y_values.length; _i++) {\n          // Horizontal line\n          var hor_p1 = new Point(this.SCREEN_BORDER.bounds.leftCenter.x, y_values[_i]);\n          var hor_p2 = new Point(this.SCREEN_BORDER.bounds.rightCenter.x, y_values[_i]);\n          var horGL = new Path.Line(hor_p1, hor_p2);\n          horGL.strokeColor = 'red';\n          horGL.strokeWidth = 0.5;\n          this.ADD_GUIDE_LINES_Y([horGL]);\n        }\n      }\n    },\n    getGuidedPosition: function getGuidedPosition(pos) {\n      var x_values = this.GUIDE_X_VALUES;\n      var y_values = this.GUIDE_Y_VALUES;\n      var snappedX = false;\n      var snappedY = false;\n      var guidedPoint = new Point(pos.x, pos.y);\n\n      for (var i = 0; i < x_values.length; i++) {\n        if (Math.abs(x_values[i] - pos.x) < Data.SNAP_THRESHOLD) {\n          guidedPoint.x = x_values[i];\n          snappedX = true;\n        }\n      }\n\n      for (var _i2 = 0; _i2 < y_values.length; _i2++) {\n        if (Math.abs(y_values[_i2] - pos.y) < Data.SNAP_THRESHOLD) {\n          guidedPoint.y = y_values[_i2];\n          snappedY = true;\n        }\n      }\n\n      return [guidedPoint, snappedX, snappedY];\n    }\n  })\n};",{"version":3,"sources":["D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js"],"names":["mapState","mapMutations","Utils","paper","Data","GuideLines","computed","methods","updateGuidePoints","objects","getUngrouped","OBJECTS","x_values","y_values","i","length","item","push","bounds","center","x","leftCenter","rightCenter","y","topCenter","bottomCenter","SET_GUIDE_X_VALUES","SET_GUIDE_Y_VALUES","clearGuideLinesX","CLEAR_GUIDE_LINES_X","clearGuideLinesY","CLEAR_GUIDE_LINES_Y","drawGuideLines","GUIDE_X_VALUES","GUIDE_Y_VALUES","ver_p1","Point","SCREEN_BORDER","ver_p2","verGL","Path","Line","strokeColor","strokeWidth","ADD_GUIDE_LINES_X","hor_p1","hor_p2","horGL","ADD_GUIDE_LINES_Y","getGuidedPosition","pos","snappedX","snappedY","guidedPoint","Math","abs","SNAP_THRESHOLD"],"mappings":"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","sourcesContent":["import { mapState, mapMutations } from \"vuex\";\r\nimport Utils from '@/Utils.js';\r\nimport paper from \"paper\";\r\nimport Data from '@/Data.js';\r\n\r\nexport const GuideLines = {\r\n    computed: {\r\n        ...mapState([\r\n            'OBJECTS',\r\n            'GUIDE_X_VALUES',\r\n            'GUIDE_Y_VALUES',\r\n            'SCREEN_BORDER'\r\n        ])\r\n    },\r\n    methods: {\r\n        ...mapMutations([\r\n            'SET_GUIDE_X_VALUES',\r\n            'SET_GUIDE_Y_VALUES',\r\n            'CLEAR_GUIDE_LINES_X',\r\n            'CLEAR_GUIDE_LINES_Y',\r\n            'ADD_GUIDE_LINES_X',\r\n            'ADD_GUIDE_LINES_Y'\r\n        ]),\r\n        updateGuidePoints: function() {\r\n            let objects = Utils.getUngrouped(this.OBJECTS);\r\n            let x_values = [];\r\n            let y_values = [];\r\n\r\n            for(let i=0; i<objects.length; i++) {\r\n                let item = objects[i];\r\n\r\n                x_values.push(item.bounds.center.x);\r\n                x_values.push(item.bounds.leftCenter.x);\r\n                x_values.push(item.bounds.rightCenter.x);\r\n\r\n                y_values.push(item.bounds.center.y);\r\n                y_values.push(item.bounds.topCenter.y);\r\n                y_values.push(item.bounds.bottomCenter.y);\r\n            }\r\n\r\n            this.SET_GUIDE_X_VALUES(x_values);\r\n            this.SET_GUIDE_Y_VALUES(y_values);\r\n        },\r\n        clearGuideLinesX: function() {\r\n            this.CLEAR_GUIDE_LINES_X();\r\n        },\r\n        clearGuideLinesY: function() {\r\n            this.CLEAR_GUIDE_LINES_Y();\r\n        },\r\n        drawGuideLines: function(x_values=null, y_values=null) {\r\n            if(x_values == null && y_values == null) {\r\n                x_values = this.GUIDE_X_VALUES;\r\n                y_values = this.GUIDE_Y_VALUES;\r\n            }\r\n\r\n            if(x_values != null) {\r\n                this.CLEAR_GUIDE_LINES_X();\r\n\r\n                for(let i=0; i<x_values.length; i++) {\r\n                    // Vertical line\r\n                    let ver_p1 = new Point(x_values[i], this.SCREEN_BORDER.bounds.bottomCenter.y);\r\n                    let ver_p2 = new Point(x_values[i], this.SCREEN_BORDER.bounds.topCenter.y);\r\n\r\n                    let verGL = new Path.Line(ver_p1, ver_p2);\r\n                    verGL.strokeColor = 'red';\r\n                    verGL.strokeWidth = 0.5;\r\n\r\n                    this.ADD_GUIDE_LINES_X([verGL]);\r\n                }\r\n            }\r\n\r\n            if(y_values != null) {\r\n                this.CLEAR_GUIDE_LINES_Y();\r\n\r\n                for(let i=0; i<y_values.length; i++) {\r\n                    // Horizontal line\r\n                    let hor_p1 = new Point(this.SCREEN_BORDER.bounds.leftCenter.x, y_values[i]);\r\n                    let hor_p2 = new Point(this.SCREEN_BORDER.bounds.rightCenter.x, y_values[i]);\r\n\r\n                    let horGL = new Path.Line(hor_p1, hor_p2);\r\n                    horGL.strokeColor = 'red';\r\n                    horGL.strokeWidth = 0.5;\r\n\r\n                    this.ADD_GUIDE_LINES_Y([horGL]);\r\n                }\r\n            }\r\n        },\r\n        getGuidedPosition: function(pos) {\r\n            const x_values = this.GUIDE_X_VALUES;\r\n            const y_values = this.GUIDE_Y_VALUES;\r\n            let snappedX = false;\r\n            let snappedY = false;\r\n            \r\n            let guidedPoint = new Point(pos.x, pos.y);\r\n\r\n            for(let i=0; i<x_values.length; i++) {\r\n                if(Math.abs(x_values[i] - pos.x) < Data.SNAP_THRESHOLD) {\r\n                    guidedPoint.x = x_values[i];\r\n                    snappedX = true;\r\n                }\r\n            }\r\n            for(let i=0; i<y_values.length; i++) {\r\n                if(Math.abs(y_values[i] - pos.y) < Data.SNAP_THRESHOLD) {\r\n                    guidedPoint.y = y_values[i];\r\n                    snappedY = true;\r\n                }\r\n            }\r\n\r\n            return [guidedPoint, snappedX, snappedY];\r\n        }\r\n    }\r\n}"]}]}