{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js!D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js","mtime":1579256975992},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _objectSpread from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\nimport { mapState, mapMutations } from \"vuex\";\nimport Utils from '@/Utils.js';\nimport paper from \"paper\";\nimport Data from '@/Data.js';\nexport var GuideLines = {\n  computed: _objectSpread({}, mapState(['OBJECTS', 'GUIDE_X_VALUES', 'GUIDE_Y_VALUES', 'SCREEN_BORDER'])),\n  methods: _objectSpread({}, mapMutations(['SET_GUIDE_X_VALUES', 'SET_GUIDE_Y_VALUES', 'CLEAR_GUIDE_LINES', 'ADD_GUIDE_LINES']), {\n    updateGuidePoints: function updateGuidePoints() {\n      var objects = Utils.getUngrouped(this.OBJECTS);\n      var x_values = [];\n      var y_values = [];\n\n      for (var i = 0; i < objects.length; i++) {\n        var item = objects[i];\n        x_values.push(item.bounds.center.x);\n        x_values.push(item.bounds.leftCenter.x);\n        x_values.push(item.bounds.rightCenter.x);\n        y_values.push(item.bounds.center.y);\n        y_values.push(item.bounds.topCenter.y);\n        y_values.push(item.bounds.bottomCenter.y);\n      }\n\n      this.SET_GUIDE_X_VALUES(x_values);\n      this.SET_GUIDE_Y_VALUES(y_values);\n    },\n    drawGuideLines: function drawGuideLines() {\n      this.CLEAR_GUIDE_LINES();\n      var x_values = this.GUIDE_X_VALUES;\n      var y_values = this.GUIDE_Y_VALUES;\n\n      for (var i = 0; i < y_values.length; i++) {\n        // Horizontal line\n        var hor_p1 = new Point(this.SCREEN_BORDER.bounds.leftCenter.x, y_values[i]);\n        var hor_p2 = new Point(this.SCREEN_BORDER.bounds.rightCenter.x, y_values[i]);\n        var horGL = new Path.Line(hor_p1, hor_p2);\n        horGL.strokeColor = 'red';\n        horGL.strokeWidth = 0.5;\n        this.ADD_GUIDE_LINES([horGL]);\n      }\n\n      for (var _i = 0; _i < x_values.length; _i++) {\n        // Vertical line\n        var ver_p1 = new Point(x_values[_i], this.SCREEN_BORDER.bounds.bottomCenter.y);\n        var ver_p2 = new Point(x_values[_i], this.SCREEN_BORDER.bounds.topCenter.y);\n        var verGL = new Path.Line(ver_p1, ver_p2);\n        verGL.strokeColor = 'red';\n        verGL.strokeWidth = 0.5;\n        this.ADD_GUIDE_LINES([verGL]);\n      }\n    },\n    getGuidedPosition: function getGuidedPosition(pos) {\n      var x_values = this.GUIDE_X_VALUES;\n      var y_values = this.GUIDE_Y_VALUES;\n      var snappedX = false;\n      var snappedY = false;\n      var guidedPoint = new Point(pos.x, pos.y);\n\n      for (var i = 0; i < x_values.length; i++) {\n        if (Math.abs(x_values[i] - pos.x) < Data.SNAP_THRESHOLD) {\n          guidedPoint.x = x_values[i];\n          snappedX = true;\n        }\n      }\n\n      for (var _i2 = 0; _i2 < y_values.length; _i2++) {\n        if (Math.abs(y_values[_i2] - pos.y) < Data.SNAP_THRESHOLD) {\n          guidedPoint.y = y_values[_i2];\n          snappedY = true;\n        }\n      }\n\n      return [guidedPoint, snappedX, snappedY];\n    }\n  })\n};",{"version":3,"sources":["D:\\GitHub\\Vectory\\src\\mixins\\GuideLines.js"],"names":["mapState","mapMutations","Utils","paper","Data","GuideLines","computed","methods","updateGuidePoints","objects","getUngrouped","OBJECTS","x_values","y_values","i","length","item","push","bounds","center","x","leftCenter","rightCenter","y","topCenter","bottomCenter","SET_GUIDE_X_VALUES","SET_GUIDE_Y_VALUES","drawGuideLines","CLEAR_GUIDE_LINES","GUIDE_X_VALUES","GUIDE_Y_VALUES","hor_p1","Point","SCREEN_BORDER","hor_p2","horGL","Path","Line","strokeColor","strokeWidth","ADD_GUIDE_LINES","ver_p1","ver_p2","verGL","getGuidedPosition","pos","snappedX","snappedY","guidedPoint","Math","abs","SNAP_THRESHOLD"],"mappings":"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","sourcesContent":["import { mapState, mapMutations } from \"vuex\";\r\nimport Utils from '@/Utils.js';\r\nimport paper from \"paper\";\r\nimport Data from '@/Data.js';\r\n\r\nexport const GuideLines = {\r\n    computed: {\r\n        ...mapState([\r\n            'OBJECTS',\r\n            'GUIDE_X_VALUES',\r\n            'GUIDE_Y_VALUES',\r\n            'SCREEN_BORDER'\r\n        ])\r\n    },\r\n    methods: {\r\n        ...mapMutations([\r\n            'SET_GUIDE_X_VALUES',\r\n            'SET_GUIDE_Y_VALUES',\r\n            'CLEAR_GUIDE_LINES',\r\n            'ADD_GUIDE_LINES'\r\n        ]),\r\n        updateGuidePoints: function() {\r\n            let objects = Utils.getUngrouped(this.OBJECTS);\r\n            let x_values = [];\r\n            let y_values = [];\r\n\r\n            for(let i=0; i<objects.length; i++) {\r\n                let item = objects[i];\r\n\r\n                x_values.push(item.bounds.center.x);\r\n                x_values.push(item.bounds.leftCenter.x);\r\n                x_values.push(item.bounds.rightCenter.x);\r\n\r\n                y_values.push(item.bounds.center.y);\r\n                y_values.push(item.bounds.topCenter.y);\r\n                y_values.push(item.bounds.bottomCenter.y);\r\n            }\r\n\r\n            this.SET_GUIDE_X_VALUES(x_values);\r\n            this.SET_GUIDE_Y_VALUES(y_values);\r\n        },\r\n        drawGuideLines: function() {\r\n            this.CLEAR_GUIDE_LINES();\r\n            let x_values = this.GUIDE_X_VALUES;\r\n            let y_values = this.GUIDE_Y_VALUES;\r\n\r\n            for(let i=0; i<y_values.length; i++) {\r\n                // Horizontal line\r\n                let hor_p1 = new Point(this.SCREEN_BORDER.bounds.leftCenter.x, y_values[i]);\r\n                let hor_p2 = new Point(this.SCREEN_BORDER.bounds.rightCenter.x, y_values[i]);\r\n\r\n                let horGL = new Path.Line(hor_p1, hor_p2);\r\n                horGL.strokeColor = 'red';\r\n                horGL.strokeWidth = 0.5;\r\n\r\n                this.ADD_GUIDE_LINES([horGL]);\r\n            }\r\n\r\n            for(let i=0; i<x_values.length; i++) {\r\n                // Vertical line\r\n                let ver_p1 = new Point(x_values[i], this.SCREEN_BORDER.bounds.bottomCenter.y);\r\n                let ver_p2 = new Point(x_values[i], this.SCREEN_BORDER.bounds.topCenter.y);\r\n\r\n                let verGL = new Path.Line(ver_p1, ver_p2);\r\n                verGL.strokeColor = 'red';\r\n                verGL.strokeWidth = 0.5;\r\n\r\n                this.ADD_GUIDE_LINES([verGL]);\r\n            }\r\n        },\r\n        getGuidedPosition: function(pos) {\r\n            const x_values = this.GUIDE_X_VALUES;\r\n            const y_values = this.GUIDE_Y_VALUES;\r\n            let snappedX = false;\r\n            let snappedY = false;\r\n            \r\n            let guidedPoint = new Point(pos.x, pos.y);\r\n\r\n            for(let i=0; i<x_values.length; i++) {\r\n                if(Math.abs(x_values[i] - pos.x) < Data.SNAP_THRESHOLD) {\r\n                    guidedPoint.x = x_values[i];\r\n                    snappedX = true;\r\n                }\r\n            }\r\n            for(let i=0; i<y_values.length; i++) {\r\n                if(Math.abs(y_values[i] - pos.y) < Data.SNAP_THRESHOLD) {\r\n                    guidedPoint.y = y_values[i];\r\n                    snappedY = true;\r\n                }\r\n            }\r\n\r\n            return [guidedPoint, snappedX, snappedY];\r\n        }\r\n    }\r\n}"]}]}