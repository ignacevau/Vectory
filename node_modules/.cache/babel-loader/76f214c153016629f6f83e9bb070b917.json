{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js!D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\components\\tools\\ToolSelect.vue","mtime":1580468443978},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _slicedToArray from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.find-index\";\nimport _Object$keys from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/object/keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _Object$assign from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/object/assign\";\nimport _toConsumableArray from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\n//\n//\n//\n//\n//\n//\n//\nimport paper from \"paper\";\nimport Tool from \"../Tool.vue\";\nimport { mapMutations, mapState } from \"vuex\";\nimport { bus, Action } from \"@/main.js\";\nimport Data from '@/Data.js';\nimport { GuideLines } from '@/mixins/GuideLines.js';\nexport default {\n  mixins: [GuideLines],\n  name: \"ToolSelect\",\n  data: function data() {\n    return {\n      snappedY: false,\n      snappedX: false\n    };\n  },\n  computed: _objectSpread({}, mapState([\"ACTIVE_TOOL\", \"TOOLSELECT\", \"OBJECTS\", \"SELECTED\", \"ACTIONS\", \"REDO_ACTIONS\", \"UI_LAYER\"])),\n  components: {\n    Tool: Tool\n  },\n  methods: _objectSpread({}, mapMutations([\"SET_ACTIVE\", \"ADD_SELECT\", \"DESELECT\", \"ADD_ACTION\", \"UNDO\", \"REDO\"]), {\n    setActive: function setActive() {\n      this.SET_ACTIVE(\"select\");\n      bus.$emit(\"activate-select\");\n      this.TOOLSELECT.activate();\n    }\n  }),\n  mounted: function mounted() {\n    var _this = this;\n\n    //#region Assigning\n    var el = document.querySelector(\"#tool-select\");\n    var hitOptions = {\n      segments: true,\n      stroke: true,\n      fill: true,\n      tolerance: 4\n    };\n    var mouseEvent; // Need this to create custom drag function\n\n    var mouseDown = false; // Path over which the mouse currently hovers\n\n    var hoverItem;\n    var hoverSelection = new Path();\n    hoverSelection.selectable = false; // Shadow paths while transforming path\n\n    var shadowPaths = []; // Transform rectangle cache\n\n    var lastTransformRect; // The selection rectangle with transform points\n\n    var transformRect = new Path();\n    var transformPoints = {\n      topLeft: null,\n      topMiddle: null,\n      topRight: null,\n      leftCenter: null,\n      rightCenter: null,\n      bottomLeft: null,\n      bottomMiddle: null,\n      bottomRight: null\n    }; // Updated through zoom\n\n    var transformBoxSize = 7 / view.zoom;\n    var transformBoxWidth = 2 / view.zoom; // Object with transform information\n\n    var transform = {\n      // Scaling\n      pivot: null,\n      dir: \"\",\n      // topLeft, topMiddle, ...\n      scale_facH: null,\n      scale_facW: null\n    };\n    var state = {\n      isHovering: false,\n      isScaling: false,\n      isDragging: false,\n      isSelecting: false,\n      snapVecLeftX: null,\n      snapVecRightX: null,\n      snapVecTopY: null,\n      snapVecBottomY: null // The relative distances used in scaling\n\n    };\n    var relH;\n    var relW;\n    var selectRectAnchor = null; // Selection rectangle\n\n    var selectRectPath = new Path();\n\n    var _lastMousePos;\n\n    var mouseDelta;\n    var flippedV = false;\n    var flippedH = false;\n    var lockScaleX = false;\n    var lockScaleY = false;\n    var point; // Object containing the data before the scaling, used for undo and shift/control modifiers\n\n    var initTransfData = {\n      height: null,\n      width: null,\n      pivot: null,\n      center: null\n    };\n    var action = {\n      move: new Action(\"move\", {\n        startPos: null,\n        endPos: null,\n        paths: null\n      }),\n      scale: new Action(\"scale\", {\n        paths: null,\n        pivot: null,\n        handle_init: null,\n        handle_end: null,\n        lockX: false,\n        lockY: false,\n        shift: false\n      })\n    }; //\n    //#region Functions\n\n    var getSelection = function getSelection() {\n      return _this.SELECTED;\n    };\n\n    var getUngrouped = function getUngrouped(items) {\n      if (items.length == 0) {\n        return [];\n      }\n\n      var result = [];\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        if (item.type == \"shape\") result.push(item);else if (item.type == \"group\") {\n          for (var j = 0; j < item.children.length; j++) {\n            result.push.apply(result, _toConsumableArray(getUngrouped([item.children[j]])));\n          }\n        } // Error catching - prevent infinite loop\n        else {\n            console.error(\"Unknown item type! Item was: \" + item);\n            return null;\n          }\n      }\n\n      return result;\n    };\n\n    function ResetHover() {\n      state.isHovering = false;\n\n      if (hoverItem) {\n        hoverItem = null;\n        hoverSelection.remove();\n      }\n    }\n\n    function DrawHoverSelection(path) {\n      hoverSelection = path.clone();\n\n      _Object$assign(hoverSelection, {\n        selectable: false,\n        strokeColor: \"#33b5ff\",\n        strokeWidth: 2 / paper.view.zoom\n      });\n    }\n\n    function DrawShadowPaths(paths) {\n      if (shadowPaths.length != 0) {\n        RemoveShadowPaths();\n      }\n\n      shadowPaths = [];\n\n      for (var i = 0; i < paths.length; i++) {\n        var _path = paths[i].clone();\n\n        _path.selectable = false;\n        _path.selected = false;\n        _path.dashArray = [5, 5];\n        _path.opacity = 0.2;\n        shadowPaths.push(_path);\n      }\n    }\n\n    function RemoveShadowPaths() {\n      if (shadowPaths.length != 0) {\n        for (var i = 0; i < shadowPaths.length; i++) {\n          shadowPaths[i].remove();\n        }\n\n        shadowPaths = [];\n      }\n    }\n\n    function HandleMouseHoverPath(item) {\n      if (!item.selected) {\n        DrawHoverSelection(item);\n      }\n    }\n\n    function HandleMouseHoverTransform(item) {\n      document.body.style.cursor = item.cursorType;\n      transform.pivot = item.opposite;\n    } // Remove the selection box with transform points\n\n\n    function hideTransformBox() {\n      transformRect.remove();\n\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        if (transformPoints[point]) {\n          transformPoints[point].remove();\n        }\n      });\n    } // Draw selection box with transform points\n\n\n    var drawTransformBox = function drawTransformBox(rect) {\n      var currentLayer = project.activeLayer;\n\n      _this.UI_LAYER.activate();\n\n      if (rect) {\n        lastTransformRect = rect;\n      }\n\n      if (!lastTransformRect) {\n        currentLayer.activate();\n        return;\n      } // Draw rect\n\n\n      transformRect = Path.Rectangle(lastTransformRect);\n      transformRect.strokeColor = \"black\";\n      transformRect.selectable = false;\n      transformRect.strokeWidth = 0.5 / view.zoom; // Calculate the positions\n\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize / 2);\n      var topMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width / 2, lastTransformRect.point.y).subtract(transformBoxSize / 2);\n      var topRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y).subtract(transformBoxSize / 2);\n      var middleLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height / 2).subtract(transformBoxSize / 2);\n      var middleRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height / 2).subtract(transformBoxSize / 2);\n      var bottomLeftPt = new Point(lastTransformRect.point.x, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize / 2);\n      var bottomMiddlePt = new Point(lastTransformRect.point.x + lastTransformRect.width / 2, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize / 2);\n      var bottomRightPt = new Point(lastTransformRect.point.x + lastTransformRect.width, lastTransformRect.point.y + lastTransformRect.height).subtract(transformBoxSize / 2); // Calculate the boxes\n\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize); // Assign the boxes\n\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\n      transformPoints.topRight = Path.Rectangle(topRightRect);\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect); // Set type\n\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        if (transformPoints[point]) {\n          transformPoints[point].type = \"transformPoint\";\n        }\n      }); // Set cursor type\n\n\n      transformPoints.topLeft.cursorType = \"nw-resize\";\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\n      transformPoints.topMiddle.cursorType = \"n-resize\";\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\n      transformPoints.topRight.cursorType = \"ne-resize\";\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\n      transformPoints.leftCenter.cursorType = \"e-resize\";\n      transformPoints.rightCenter.cursorType = \"e-resize\"; // Set names\n\n      transformPoints.topLeft.name = \"topLeft\";\n      transformPoints.topRight.name = \"topRight\";\n      transformPoints.topMiddle.name = \"topCenter\";\n      transformPoints.leftCenter.name = \"leftCenter\";\n      transformPoints.rightCenter.name = \"rightCenter\";\n      transformPoints.bottomLeft.name = \"bottomLeft\";\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\n      transformPoints.bottomRight.name = \"bottomRight\"; // Set the box colors\n\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        if (transformPoints[point]) {\n          transformPoints[point].selectable = false;\n          transformPoints[point].strokeColor = \"blue\";\n          transformPoints[point].fillColor = \"white\";\n          transformPoints[point].strokeWidth = transformBoxWidth;\n        }\n      });\n\n      currentLayer.activate();\n    }; // Redraw the selection box with transform points\n\n\n    var updateTransformBox = function updateTransformBox(bounds) {\n      hideTransformBox();\n\n      if (_this.SELECTED.length > 0) {\n        if (bounds) {\n          drawTransformBox(bounds);\n        } else {\n          drawTransformBox();\n        }\n      }\n    }; // Hide the transform points, but keep the box (e.g. while moving selection)\n\n\n    function HideTransformPoints() {\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        transformPoints[point].visible = false;\n      });\n    }\n\n    function ShowTransformPoints() {\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        transformPoints[point].visible = true;\n      });\n    }\n\n    function CreateSelectionRectanglePath(_ref) {\n      var rect = _ref.rect,\n          strokeWidth = _ref.strokeWidth,\n          strokeColor = _ref.strokeColor,\n          dashArray = _ref.dashArray;\n      var path = Path.Rectangle(rect);\n\n      _Object$assign(path, {\n        strokeWidth: strokeWidth,\n        strokeColor: strokeColor,\n        dashArray: dashArray,\n        selectable: false\n      });\n\n      return path;\n    } //#region Group\n\n\n    var SelectGroup = function SelectGroup(group) {\n      if (!group.selected) {\n        var ungrouped = getUngrouped([group]);\n\n        for (var i = 0; i < ungrouped.length; i++) {\n          ungrouped[i].selected = true;\n        }\n\n        group.selected = true;\n\n        _this.ADD_SELECT(group);\n      }\n    };\n\n    function DeselectGroup(group) {\n      DeselectShape(group);\n    }\n\n    function CheckGroupIntersection(group, rect) {\n      // Check for every child in the group\n      var children = getUngrouped(group.children);\n\n      for (var j = 0; j < children.length; j++) {\n        console.log(\"child\"); // Check for intersection with selection rect\n\n        if (rect.intersects(children[j])) {\n          return {\n            success: true\n          };\n        }\n      }\n\n      return {\n        success: false\n      };\n    }\n\n    function CheckGroupInsideRect(group, rect) {\n      var children = getUngrouped(group.children);\n\n      for (var i = 0; i < children.length; i++) {\n        if (children[i].isInside(rect) && children[i].selectable) {\n          return {\n            success: true\n          };\n        }\n      }\n\n      return {\n        success: false\n      };\n    } //\n    //#region Shape\n\n\n    var SelectShape = function SelectShape(shape) {\n      if (!shape.selected) {\n        shape.selected = true;\n\n        _this.ADD_SELECT(shape);\n      }\n    };\n\n    var DeselectShape = function DeselectShape(shape) {\n      shape.selected = false;\n      var index = getSelection().findIndex(function (x) {\n        return x === shape;\n      });\n\n      if (index != -1) {\n        getSelection().splice(index, 1);\n      }\n    };\n\n    function CheckShapeIntersection(shape, rectPath) {\n      // Selection rect intersects with the shape\n      if (rectPath.intersects(shape) && shape.selectable) {\n        return {\n          success: true\n        };\n      }\n\n      return {\n        success: false\n      };\n    }\n\n    function CheckShapeInsideRect(shape, rect) {\n      // Shape is inside the selection rect\n      if (shape.isInside(rect) && shape.selectable) {\n        return {\n          success: true\n        };\n      }\n\n      return {\n        success: false\n      };\n    } //\n    // Return the opposite point on the transform box\n\n\n    function getOppositePoint(point, x, y, bounds) {\n      if (!point) {\n        alert(\"warning: 001\");\n        return;\n      }\n\n      var _point = point;\n      var opposite = bounds.center.add(bounds.center.subtract(point));\n\n      if (x) {\n        _point = new Point(opposite.x, _point.y);\n      }\n\n      if (y) {\n        _point = new Point(_point.x, opposite.y);\n      }\n\n      return _point;\n    } // Get the selection rectangle\n\n\n    var getBounds = function getBounds(shapes) {\n      if (shapes.length == 0) {\n        return null;\n      }\n\n      var _temp = [];\n\n      for (var i = 0; i < shapes.length; i++) {\n        var item = shapes[i];\n\n        if (item.type == \"group\") {\n          var ungrouped = getUngrouped(item.children);\n\n          for (var j = 0; j < ungrouped.length; j++) {\n            _temp.push(ungrouped[j].clone());\n          }\n        } else if (item.type == \"shape\") {\n          _temp.push(item.clone());\n        }\n      } // Make a compoundpath to get the bounds for the transform box\n\n\n      var _grouped = new CompoundPath({\n        children: _temp\n      });\n\n      var rect = _grouped.bounds;\n\n      _grouped.remove();\n\n      return rect;\n    };\n\n    function RedrawTransformPoints() {\n      _Object$keys(transformPoints).forEach(function (point, index) {\n        transformPoints[point].position = transformRect.bounds[point];\n      });\n    } // While scaling check whether the selection should be flipped\n\n\n    function checkScaleFlip() {\n      if (relH > 0 && flippedV && !lockScaleY) {\n        transform.scale_facH = -transform.scale_facH;\n        flippedV = false;\n      } else if (relH < 0 && !flippedV && !lockScaleY) {\n        transform.scale_facH = -transform.scale_facH;\n        flippedV = true;\n      }\n\n      if (relW > 0 && !flippedH && !lockScaleX) {\n        transform.scale_facW = -transform.scale_facW;\n        flippedH = true;\n      }\n\n      if (relW < 0 && flippedH && !lockScaleX) {\n        transform.scale_facW = -transform.scale_facW;\n        flippedH = false;\n      }\n    } // Handle ctrl-key presses\n\n\n    function handleControlKey() {\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].translate(delta);\n      }\n\n      transformRect.position = initTransfData.center;\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\n      action.scale.data.pivot = point;\n      mouseDrag(mouseEvent);\n    } //\n    //#region Mouse down\n\n\n    this.TOOLSELECT.onMouseDown = function (e) {\n      mouseDown = true;\n      _lastMousePos = e.point;\n\n      if (_this.SELECTED.length != 0) {\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\n          document.body.style.cursor = \"move\";\n          state.isDragging = true; // Hide scaling points when moving the selection\n\n          HideTransformPoints();\n          DrawShadowPaths(getUngrouped(getSelection()));\n          state.snapVecLeftX = getBounds(getSelection()).leftCenter.subtract(e.point);\n          state.snapVecRightX = getBounds(getSelection()).rightCenter.subtract(e.point);\n          state.snapVecTopY = getBounds(getSelection()).topCenter.subtract(e.point);\n          state.snapVecBottomY = getBounds(getSelection()).bottomCenter.subtract(e.point);\n          action.move = new Action(\"move\", {\n            paths: getUngrouped(getSelection()),\n            startPos: e.point,\n            endPos: null\n          });\n          return;\n        }\n      }\n\n      hideTransformBox();\n\n      if (state.isHovering && hoverItem.type == \"transformPoint\") {\n        var bounds = getBounds(getSelection());\n        state.isScaling = true; // Hide scaling points when scaling the selection\n\n        HideTransformPoints();\n        DrawShadowPaths(getUngrouped(getSelection()));\n        drawTransformBox();\n        transform.dir = e.item.name;\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds); // Updating the backup data (for shift-scale and for undo)\n\n        initTransfData.width = bounds.width;\n        initTransfData.height = bounds.height;\n        initTransfData.pivot = new Point(point.x, point.y);\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\n\n        switch (transform.dir) {\n          case \"bottomLeft\":\n            flippedV = false;\n            flippedH = false;\n            lockScaleX = false;\n            lockScaleY = false;\n            break;\n\n          case \"topLeft\":\n            flippedV = true;\n            flippedH = false;\n            lockScaleX = false;\n            lockScaleY = false;\n            break;\n\n          case \"bottomRight\":\n            flippedV = false;\n            flippedH = true;\n            lockScaleX = false;\n            lockScaleY = false;\n            break;\n\n          case \"topRight\":\n            flippedV = true;\n            flippedH = true;\n            lockScaleX = false;\n            lockScaleY = false;\n            break;\n\n          case \"bottomCenter\":\n            flippedV = false;\n            flippedH = false;\n            lockScaleX = true;\n            lockScaleY = false;\n            break;\n\n          case \"topCenter\":\n            flippedV = true;\n            flippedH = false;\n            lockScaleX = true;\n            lockScaleY = false;\n            break;\n\n          case \"leftCenter\":\n            flippedV = false;\n            flippedH = false;\n            lockScaleX = false;\n            lockScaleY = true;\n            break;\n\n          case \"rightCenter\":\n            flippedV = false;\n            flippedH = true;\n            lockScaleX = false;\n            lockScaleY = true;\n            break;\n        }\n\n        if (e.modifiers.control) {\n          handleControlKey();\n        }\n\n        action.scale = new Action(\"scale\", {\n          paths: getUngrouped(getSelection()),\n          pivot: initTransfData.pivot,\n          lockX: lockScaleX,\n          lockY: lockScaleY,\n          handle_init: bounds[transform.dir],\n          handle_end: null,\n          shift: false\n        });\n        mouseDrag(e);\n        return;\n      }\n\n      transformRect = new Path(); // Mouse is not over a shape\n\n      if (!state.isHovering) {\n        _this.DESELECT();\n      } // Mouse is over a shape\n\n\n      if (hoverSelection) {\n        hoverSelection.remove();\n\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\n          // Shift key is pressed\n          if (e.modifiers.shift) {\n            hoverItem.selected = true;\n\n            _this.ADD_SELECT(hoverItem);\n          } // Shift key is not pressed\n          else {\n              project.deselectAll();\n\n              _this.DESELECT();\n\n              SelectShape(hoverItem);\n            }\n\n          drawTransformBox(getBounds(getSelection()));\n        }\n      }\n\n      if (!e.item) {\n        project.deselectAll();\n\n        _this.DESELECT();\n\n        selectRectAnchor = e.point;\n        state.isSelecting = true;\n      }\n    }; //\n    //#region Mouse move\n\n\n    this.TOOLSELECT.onMouseMove = function (e) {\n      mouseEvent = e; // Reset cursor style\n\n      document.body.style.cursor = \"default\";\n      ResetHover(); // Mouse is hovering over an item\n\n      if (e.item && !state.isSelecting && !state.isDragging) {\n        if (e.item.selectable) {\n          hoverItem = e.item;\n          state.isHovering = true;\n          HandleMouseHoverPath(hoverItem);\n        } // Mouse is hovering over transform-handle (not selectable)\n        else if (e.item.type == \"transformPoint\") {\n            hoverItem = e.item;\n            state.isHovering = true;\n            HandleMouseHoverTransform(hoverItem);\n          }\n      }\n\n      if (state.isSelecting && !state.isHovering) {\n        selectRectPath.remove();\n        var selectRect = new Rectangle(selectRectAnchor, e.point);\n        selectRectPath = CreateSelectionRectanglePath({\n          rect: selectRect,\n          strokeWidth: 0.5 / view.zoom,\n          strokeColor: \"black\",\n          dashArray: [4 / view.zoom, 3 / view.zoom]\n        });\n        var objects = _this.OBJECTS;\n\n        for (var i = 0; i < objects.length; i++) {\n          /* First, check for intersections between the shapes and the selection rectangle,\r\n            if none, check whether the shapes are inside the rectangle */\n          var obj = objects[i]; // Group\n\n          if (obj.type == \"group\" && obj.selectable) {\n            console.log(\"checking group\");\n\n            var _isIntersect = CheckGroupIntersection(obj, selectRectPath);\n\n            if (_isIntersect.success) SelectGroup(obj);else {\n              var _isInside = CheckGroupInsideRect(obj, selectRect);\n\n              if (_isInside.success) SelectGroup(obj);else {\n                DeselectGroup(obj);\n              }\n            }\n          } // Shape\n          else if (obj.type == \"shape\") {\n              var _isIntersect2 = CheckShapeIntersection(obj, selectRectPath);\n\n              if (_isIntersect2.success) SelectShape(obj);else {\n                var _isInside2 = CheckShapeInsideRect(obj, selectRect);\n\n                if (_isInside2.success) SelectShape(obj);else {\n                  DeselectShape(obj);\n                }\n              }\n            }\n        }\n      }\n\n      if (_this.SELECTED.length != 0) {\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\n          document.body.style.cursor = \"move\";\n        }\n      } // Call mouseDrag AFTER mouseMove\n\n\n      if (mouseDown) {\n        mouseDrag(e);\n      }\n    }; //\n    //#region Mouse up\n\n\n    this.TOOLSELECT.onMouseUp = function (e) {\n      mouseDown = false;\n      var _return = false;\n      selectRectAnchor = null;\n      state.isSelecting = false;\n      selectRectPath.remove();\n\n      if (getSelection().length == 0) {\n        return;\n      }\n\n      if (state.isScaling) {\n        lockScaleX = false;\n        lockScaleY = false;\n        var bounds = getBounds(getSelection());\n        action.scale.data.handle_end = getOppositePoint(point, true, true, bounds);\n\n        if (e.modifiers.shift) {\n          action.scale.data.shift = true;\n        }\n\n        if (e.modifiers.control) {\n          action.scale.data.handle_end = transformRect.bounds[transform.dir];\n          action.scale.data.pivot = new Point(initTransfData.center.x, initTransfData.center.y);\n        }\n\n        _this.ADD_ACTION(action.scale);\n\n        state.isScaling = false; // Scaling points where hidden while moving selection\n\n        ShowTransformPoints();\n        RemoveShadowPaths();\n        _return = true; // Update the guide-points\n\n        _this.updateGuidePoints();\n      }\n\n      if (state.isDragging) {\n        action.move.data.endPos = e.point;\n\n        _this.ADD_ACTION(action.move);\n\n        state.isDragging = false; // Scaling points where hidden while moving selection\n\n        ShowTransformPoints();\n        RemoveShadowPaths();\n        _return = true; // Update the guide-points\n\n        _this.updateGuidePoints();\n      }\n\n      if (_this.snappedX) _this.clearGuideLinesX();\n      if (_this.snappedY) _this.clearGuideLinesY(); // Update transform box with new rectangle\n\n      hideTransformBox();\n      drawTransformBox(getBounds(getSelection()));\n\n      if (_return) {\n        return;\n      }\n    }; //\n    //#region Mouse drag\n\n\n    var mouseDrag = function mouseDrag(e) {\n      mouseDelta = e.point.subtract(_lastMousePos);\n\n      if (Data.SNAP_MOVE && state.isDragging) {\n        var snapY = null;\n        var snapX = null; // Snapping y-axis\n\n        if (mouseDelta.y != 0) {\n          var snappedY = false; // Check for top snap\n\n          var guided, _;\n\n          var _this$getGuidedPositi = _this.getGuidedPosition(e.point.add(state.snapVecTopY));\n\n          var _this$getGuidedPositi2 = _slicedToArray(_this$getGuidedPositi, 3);\n\n          guided = _this$getGuidedPositi2[0];\n          _ = _this$getGuidedPositi2[1];\n          snappedY = _this$getGuidedPositi2[2];\n          mouseDelta.y = guided.subtract(transformRect.bounds.topCenter).y;\n\n          if (snappedY) {\n            snapY = guided.y;\n          } //If top hasn't snapped, check for bottom snap\n          else {\n              var _this$getGuidedPositi3 = _this.getGuidedPosition(e.point.add(state.snapVecBottomY));\n\n              var _this$getGuidedPositi4 = _slicedToArray(_this$getGuidedPositi3, 3);\n\n              guided = _this$getGuidedPositi4[0];\n              _ = _this$getGuidedPositi4[1];\n              snappedY = _this$getGuidedPositi4[2];\n              mouseDelta.y = guided.subtract(transformRect.bounds.bottomCenter).y;\n\n              if (snappedY) {\n                snapY = guided.y;\n              }\n            } // If snapped to a y-line, display the line\n\n\n          if (snapY != null) {\n            _this.drawGuideLines(null, [snapY]);\n\n            _this.snappedY = true;\n          } else if (_this.snappedY) {\n            _this.snappedY = false;\n\n            _this.clearGuideLinesY();\n          }\n        } // Snapping x-axis\n\n\n        if (mouseDelta.x != 0) {\n          var snappedX = false; // Check for left snap\n\n          var _guided, _2;\n\n          var _this$getGuidedPositi5 = _this.getGuidedPosition(e.point.add(state.snapVecLeftX));\n\n          var _this$getGuidedPositi6 = _slicedToArray(_this$getGuidedPositi5, 3);\n\n          _guided = _this$getGuidedPositi6[0];\n          snappedX = _this$getGuidedPositi6[1];\n          _2 = _this$getGuidedPositi6[2];\n          mouseDelta.x = _guided.subtract(transformRect.bounds.leftCenter).x;\n\n          if (snappedX) {\n            snapX = _guided.x;\n          } // If left hasn't snapped, check for right snap\n          else {\n              var _this$getGuidedPositi7 = _this.getGuidedPosition(e.point.add(state.snapVecRightX));\n\n              var _this$getGuidedPositi8 = _slicedToArray(_this$getGuidedPositi7, 3);\n\n              _guided = _this$getGuidedPositi8[0];\n              snappedX = _this$getGuidedPositi8[1];\n              _2 = _this$getGuidedPositi8[2];\n              mouseDelta.x = _guided.subtract(transformRect.bounds.rightCenter).x;\n\n              if (snappedX) {\n                snapX = _guided.x;\n              }\n            } // If snapped to a x-line, display the line\n\n\n          if (snapX != null) {\n            _this.drawGuideLines([snapX], null);\n\n            _this.snappedX = true;\n          } else if (_this.snappedX) {\n            _this.snappedX = false;\n\n            _this.clearGuideLinesX();\n          }\n        }\n      }\n\n      _lastMousePos = e.point;\n      var path = transformRect; // User is moving the selection\n\n      if (state.isDragging) {\n        var selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].translate(mouseDelta);\n        }\n\n        transformRect.translate(mouseDelta);\n        lastTransformRect = transformRect.bounds;\n\n        _Object$keys(transformPoints).forEach(function (point, index) {\n          transformPoints[point].translate(mouseDelta);\n        });\n\n        return;\n      } // User is scaling the selection\n\n\n      if (state.isScaling) {\n        // Add snapping if enabled\n        if (Data.SNAP_SCALE) {\n          if (Math.abs(transform.scale_facH) > 0.1 && Math.abs(transform.scale_facW) > 0.1) {\n            var _this$getGuidedPositi9 = _this.getGuidedPosition(e.point),\n                _this$getGuidedPositi10 = _slicedToArray(_this$getGuidedPositi9, 3),\n                _guided2 = _this$getGuidedPositi10[0],\n                xsnapped = _this$getGuidedPositi10[1],\n                ysnapped = _this$getGuidedPositi10[2];\n\n            if (xsnapped) {\n              _this.drawGuideLines([_guided2.x], null);\n\n              _this.snappedX = true;\n            } else if (_this.snappedX) {\n              _this.snappedX = false;\n\n              _this.clearGuideLinesX();\n            }\n\n            if (ysnapped) {\n              _this.drawGuideLines(null, [_guided2.y]);\n\n              _this.snappedY = true;\n            } else if (_this.snappedY) {\n              _this.snappedY = false;\n\n              _this.clearGuideLinesY();\n            }\n\n            e.point = _guided2;\n          }\n        }\n\n        var bounds = transformRect.bounds;\n\n        if (!lockScaleY) {\n          relH = e.point.subtract(point).y;\n          transform.scale_facH = Math.abs(relH) / bounds.height;\n        } else {\n          transform.scale_facH = 1;\n        }\n\n        if (!lockScaleX) {\n          relW = e.point.subtract(point).x;\n          transform.scale_facW = Math.abs(relW) / bounds.width;\n        } else {\n          transform.scale_facW = 1;\n        }\n\n        if (Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\n          return;\n        }\n\n        if (Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\n          return;\n        }\n\n        if (!e.modifiers.shift) {\n          checkScaleFlip();\n        }\n\n        if (e.modifiers.shift) {\n          var min = Math.min(Math.abs(transform.scale_facH), Math.abs(transform.scale_facW));\n\n          if (lockScaleY) {\n            min = Math.abs(transform.scale_facW);\n          } else if (lockScaleX) {\n            min = Math.abs(transform.scale_facH);\n          }\n\n          transform.scale_facH = min;\n          transform.scale_facW = min;\n        }\n\n        if (e.modifiers.control) {\n          if (!lockScaleX) {\n            transform.scale_facW *= 2;\n          }\n\n          if (!lockScaleY) {\n            transform.scale_facH *= 2;\n          }\n        } // Scale all the selected items\n\n\n        var _selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < _selection.length; i++) {\n          _selection[i].scale(transform.scale_facW, transform.scale_facH, point);\n        }\n\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point); // Don't show the points while scaling\n\n        _Object$keys(transformPoints).forEach(function (point, index) {\n          transformPoints[point].remove();\n        });\n      }\n    }; //\n    //#region events\n    // - user is zooming -\n\n\n    bus.$on(\"zoom\", function () {\n      // Keep the transform box's width constant over zoom\n      transformRect.strokeWidth = 0.5 / view.zoom;\n      transformBoxSize = 7 / view.zoom;\n      transformBoxWidth = 2 / view.zoom;\n\n      if (getSelection().length > 0) {\n        updateTransformBox();\n      }\n    }); // - Ctrl + Z -\n\n    bus.$on(\"undo\", function () {\n      if (_this.ACTIONS.length > 0) {\n        _this.UNDO();\n\n        project.deselectAll();\n        var selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].selected = true;\n        }\n\n        _this.updateGuidePoints();\n\n        if (_this.ACTIVE_TOOL == 'select') {\n          updateTransformBox(getBounds(getSelection()));\n        }\n      }\n    }); // - Ctrl + Shift + Z -\n\n    bus.$on(\"redo\", function () {\n      if (_this.REDO_ACTIONS.length > 0) {\n        _this.REDO();\n\n        project.deselectAll();\n        var selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].selected = true;\n        }\n\n        _this.updateGuidePoints();\n\n        if (_this.ACTIVE_TOOL == 'select') {\n          updateTransformBox(getBounds(getSelection()));\n        }\n      }\n    }); // - delete key pressed -\n\n    bus.$on(\"delete_selection\", function () {\n      _this.DESELECT();\n\n      hideTransformBox();\n    }); // - shift key pressed -\n\n    bus.$on(\"shift\", function () {\n      if (state.isScaling) {\n        var bounds = getBounds(getSelection());\n        var facH_init = initTransfData.height / bounds.height;\n        var facW_init = initTransfData.width / bounds.width; // Scale the selection to its initial size\n\n        var selection = getUngrouped(getSelection());\n        var rel;\n\n        if (lockScaleX) {\n          rel = Math.abs(relH);\n        } else if (lockScaleY) {\n          rel = Math.abs(relW);\n        } else {\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\n        }\n\n        var fac = rel / Math.min(initTransfData.width, initTransfData.height);\n        transform.scale_facW = facW_init * fac;\n        transform.scale_facH = facH_init * fac; // Resize the selection to the current size without deformation\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].scale(transform.scale_facW, transform.scale_facH, point);\n        } // Resize transform rect as well\n\n\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\n        mouseDrag(mouseEvent);\n      }\n    }); // - control key pressed -\n\n    bus.$on(\"control\", function () {\n      if (state.isScaling) {\n        handleControlKey();\n      }\n    }); // - control key released -\n\n    bus.$on(\"control_up\", function () {\n      if (state.isScaling) {\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\n        action.scale.data.pivot = point;\n        relH = mouseEvent.point.subtract(point).y;\n        relW = mouseEvent.point.subtract(point).x;\n        var curDistPt;\n\n        if (relH >= 0 && relW >= 0) {\n          curDistPt = transformRect.bounds.topLeft;\n          flippedV = false;\n          flippedH = true;\n        } else if (relH >= 0 && relW < 0) {\n          curDistPt = transformRect.bounds.topRight;\n          flippedV = false;\n          flippedH = false;\n        } else if (relH < 0 && relW >= 0) {\n          curDistPt = transformRect.bounds.bottomLeft;\n          flippedV = true;\n          flippedH = true;\n        } else if (relH < 0 && relW < 0) {\n          curDistPt = transformRect.bounds.bottomRight;\n          flippedV = true;\n          flippedH = false;\n        }\n\n        var delta = initTransfData.pivot.subtract(curDistPt);\n\n        if (lockScaleX) {\n          delta.x = 0;\n        } else if (lockScaleY) {\n          delta.y = 0;\n        }\n\n        transformRect.translate(delta);\n        var selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].translate(delta);\n        }\n\n        mouseDrag(mouseEvent);\n      }\n    });\n    bus.$on(\"hide-transformbox\", function () {\n      hideTransformBox();\n    }); // - switched to another tool -\n\n    bus.$on(\"deactivate-select\", function () {\n      for (var i = 0; i < getSelection().length; i++) {\n        DeselectShape(getSelection());\n      }\n\n      if (_this.ACTIVE_TOOL != \"pointer\") {\n        _this.DESELECT();\n      }\n\n      hideTransformBox();\n    });\n    bus.$on(\"activate-select\", function () {\n      if (_this.SELECTED.length > 0) {\n        for (var i = 0; i < getSelection().length; i++) {\n          SelectShape(getSelection()[i]);\n        } // There could've been drawn a new shape\n\n\n        _this.updateGuidePoints();\n\n        drawTransformBox(getBounds(getSelection()));\n      }\n    });\n    bus.$on(\"set_color_stroke\", function (color) {\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].strokeColor = color;\n      }\n    });\n    bus.$on(\"set_color_fill\", function (color) {\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].fillColor = color;\n      }\n    });\n    bus.$on(\"set_width_stroke\", function (width) {\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].strokeWidth = width;\n      }\n    });\n    bus.$on(\"set_cap_stroke\", function (type) {\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].strokeCap = type;\n      }\n    });\n    bus.$on(\"set_opacity\", function (opacity) {\n      var selection = getUngrouped(getSelection());\n\n      for (var i = 0; i < selection.length; i++) {\n        selection[i].opacity = opacity / 100;\n      }\n    });\n    bus.$on(\"flip-hor\", function () {\n      if (_this.SELECTED.length > 0) {\n        var bounds = getBounds(getSelection());\n        var center = bounds.center;\n        var selection = getUngrouped(getSelection());\n\n        for (var i = 0; i < selection.length; i++) {\n          selection[i].scale(1, -1, center);\n        }\n      }\n    });\n    bus.$on(\"flip-ver\", function () {\n      if (_this.SELECTED.length > 0) {\n        var bounds = getBounds(getSelection());\n        var center = bounds.center;\n\n        for (var i = 0; i < _this.SELECTED.length; i++) {\n          _this.SELECTED[i].scale(-1, 1, center);\n        }\n      }\n    }); //\n    //#region Aligning\n    // Horizontal\n\n    bus.$on('align-hor-center', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var dist_x = Data.CENTER_HOR - bounds.center.x;\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([dist_x, 0]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(dist_x, 0))\n      });\n\n      _this.ADD_ACTION(action.move);\n    });\n    bus.$on('align-hor-left', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var docLeft = Data.CENTER_HOR - Data.DOCUMENT_WIDTH / 2;\n      var dist_x = docLeft - bounds.x;\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([dist_x, 0]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(dist_x, 0))\n      });\n\n      _this.ADD_ACTION(action.move);\n    });\n    bus.$on('align-hor-right', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var docRight = Data.CENTER_HOR + Data.DOCUMENT_WIDTH / 2;\n      var dist_x = docRight - (bounds.x + bounds.width);\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([dist_x, 0]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(dist_x, 0))\n      });\n\n      _this.ADD_ACTION(action.move);\n    }); // Vertical\n\n    bus.$on('align-ver-center', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var dist_y = Data.CENTER_VER - bounds.center.y;\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([0, dist_y]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(0, dist_y))\n      });\n\n      _this.ADD_ACTION(action.move);\n    });\n    bus.$on('align-ver-top', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var docTop = Data.CENTER_VER - Data.DOCUMENT_HEIGHT / 2;\n      var dist_y = docTop - bounds.y;\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([0, dist_y]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(0, dist_y))\n      });\n\n      _this.ADD_ACTION(action.move);\n    });\n    bus.$on('align-ver-bottom', function () {\n      var selection = getSelection();\n      var bounds = getBounds(selection);\n      var docTop = Data.CENTER_VER + Data.DOCUMENT_HEIGHT / 2;\n      var dist_y = docTop - (bounds.y + bounds.height);\n      var ungrouped = getUngrouped(selection);\n\n      for (var i = 0; i < ungrouped.length; i++) {\n        ungrouped[i].translate([0, dist_y]);\n      }\n\n      updateTransformBox(getBounds(getSelection())); // Make undo-abel\n\n      action.move = new Action(\"move\", {\n        paths: ungrouped,\n        startPos: bounds.center,\n        endPos: bounds.center.add(new Point(0, dist_y))\n      });\n\n      _this.ADD_ACTION(action.move);\n    }); //\n  }\n};",{"version":3,"sources":["ToolSelect.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\r\n  <tool imgSource=\"tool-select.png\" @isActive=\"setActive\" />\r\n</template>\r\n\r\n\r\n\r\n\r\n<script>\r\nimport paper from \"paper\";\r\nimport Tool from \"../Tool.vue\";\r\nimport { mapMutations, mapState } from \"vuex\";\r\nimport { bus, Action } from \"@/main.js\";\r\nimport Data from '@/Data.js';\r\nimport { GuideLines } from '@/mixins/GuideLines.js';\r\n\r\nexport default {\r\n  mixins: [GuideLines],\r\n  name: \"ToolSelect\",\r\n  data: function() {\r\n    return {\r\n      snappedY: false,\r\n      snappedX: false\r\n    }\r\n  },\r\n  computed: {\r\n    ...mapState([\r\n      \"ACTIVE_TOOL\",\r\n      \"TOOLSELECT\",\r\n      \"OBJECTS\",\r\n      \"SELECTED\",\r\n      \"ACTIONS\",\r\n      \"REDO_ACTIONS\",\r\n      \"UI_LAYER\"\r\n      ])\r\n  },\r\n  components: {\r\n    Tool\r\n  },\r\n  methods: {\r\n    ...mapMutations([\r\n      \"SET_ACTIVE\",\r\n      \"ADD_SELECT\",\r\n      \"DESELECT\",\r\n      \"ADD_ACTION\",\r\n      \"UNDO\",\r\n      \"REDO\"\r\n    ]),\r\n    setActive: function() {\r\n      this.SET_ACTIVE(\"select\");\r\n\r\n      bus.$emit(\"activate-select\");\r\n      this.TOOLSELECT.activate();\r\n    }\r\n  },\r\n  mounted: function() {\r\n//#region Assigning\r\n    var el = document.querySelector(\"#tool-select\");\r\n\r\n    var hitOptions = {\r\n      segments: true,\r\n      stroke: true,\r\n      fill: true,\r\n      tolerance: 4\r\n    };\r\n\r\n    var mouseEvent;\r\n\r\n    // Need this to create custom drag function\r\n    var mouseDown = false;\r\n\r\n    // Path over which the mouse currently hovers\r\n    let hoverItem;\r\n    var hoverSelection = new Path();\r\n    hoverSelection.selectable = false;\r\n\r\n    // Shadow paths while transforming path\r\n    let shadowPaths = [];\r\n\r\n    // Transform rectangle cache\r\n    var lastTransformRect;\r\n\r\n    // The selection rectangle with transform points\r\n    var transformRect = new Path();\r\n    var transformPoints = {\r\n      topLeft: null,\r\n      topMiddle: null,\r\n      topRight: null,\r\n\r\n      leftCenter: null,\r\n      rightCenter: null,\r\n\r\n      bottomLeft: null,\r\n      bottomMiddle: null,\r\n      bottomRight: null\r\n    };\r\n\r\n    // Updated through zoom\r\n    var transformBoxSize = 7 / view.zoom;\r\n    var transformBoxWidth = 2 / view.zoom;\r\n\r\n    // Object with transform information\r\n    var transform = {\r\n      // Scaling\r\n      pivot: null,\r\n      dir: \"\", // topLeft, topMiddle, ...\r\n\r\n      scale_facH: null,\r\n      scale_facW: null,\r\n    };\r\n\r\n    const state = {\r\n      isHovering: false,\r\n      isScaling: false,\r\n      isDragging: false,\r\n      isSelecting: false,\r\n      \r\n      snapVecLeftX: null,\r\n      snapVecRightX: null,\r\n      snapVecTopY: null,\r\n      snapVecBottomY: null\r\n    }\r\n\r\n    // The relative distances used in scaling\r\n    var relH;\r\n    var relW;\r\n\r\n    var selectRectAnchor = null;\r\n\r\n    // Selection rectangle\r\n    let selectRectPath = new Path();\r\n\r\n    var _lastMousePos;\r\n    var mouseDelta;\r\n\r\n    var flippedV = false;\r\n    var flippedH = false;\r\n    var lockScaleX = false;\r\n    var lockScaleY = false;\r\n    var point;\r\n\r\n    // Object containing the data before the scaling, used for undo and shift/control modifiers\r\n    var initTransfData = {\r\n      height: null,\r\n      width: null,\r\n      pivot: null,\r\n      center: null\r\n    };\r\n\r\n    var action = {\r\n      move: new Action(\"move\", {\r\n        startPos: null,\r\n        endPos: null,\r\n        paths: null\r\n      }),\r\n      scale: new Action(\"scale\", {\r\n        paths: null,\r\n        pivot: null,\r\n        handle_init: null,\r\n        handle_end: null,\r\n        lockX: false,\r\n        lockY: false,\r\n        shift: false\r\n      })\r\n    };\r\n//\r\n\r\n//#region Functions\r\n    let getSelection = () => {\r\n      return this.SELECTED;\r\n    }\r\n\r\n    let getUngrouped = (items) => {\r\n      if(items.length == 0) {\r\n        return [];\r\n      }\r\n\r\n      let result = [];\r\n\r\n      for(let i=0; i<items.length; i++) {\r\n        let item = items[i];\r\n\r\n        if(item.type == \"shape\")\r\n          result.push(item)\r\n        else if(item.type == \"group\") {\r\n          for(let j=0; j<item.children.length; j++) {\r\n            result.push(...getUngrouped([item.children[j]]));\r\n          }\r\n        }\r\n\r\n        // Error catching - prevent infinite loop\r\n        else {\r\n          console.error(\"Unknown item type! Item was: \" + item);\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function ResetHover() {\r\n      state.isHovering = false;\r\n\r\n      if (hoverItem) {\r\n        hoverItem = null;\r\n        hoverSelection.remove();\r\n      }\r\n    }\r\n\r\n    function DrawHoverSelection(path) {\r\n      hoverSelection = path.clone();\r\n      Object.assign(hoverSelection, {\r\n        selectable: false,\r\n        strokeColor: \"#33b5ff\",\r\n        strokeWidth: 2 / paper.view.zoom\r\n      });\r\n    }\r\n\r\n    function DrawShadowPaths(paths) {\r\n      if(shadowPaths.length != 0) {\r\n        RemoveShadowPaths();\r\n      }\r\n\r\n      shadowPaths = [];\r\n      for(let i=0; i<paths.length; i++) {\r\n        let _path = paths[i].clone();\r\n        _path.selectable = false;\r\n        _path.selected = false;\r\n        _path.dashArray = [5, 5];\r\n        _path.opacity = 0.2;\r\n        shadowPaths.push(_path);\r\n      }\r\n    }\r\n\r\n    function RemoveShadowPaths() {\r\n      if(shadowPaths.length != 0) {\r\n        for(let i=0; i<shadowPaths.length; i++) {\r\n          shadowPaths[i].remove();\r\n        }\r\n        shadowPaths = [];\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverPath(item) {\r\n      if (!item.selected) {\r\n        DrawHoverSelection(item);\r\n      }\r\n    }\r\n\r\n    function HandleMouseHoverTransform(item) {\r\n      document.body.style.cursor = item.cursorType;\r\n      transform.pivot = item.opposite;\r\n    }\r\n\r\n    // Remove the selection box with transform points\r\n    function hideTransformBox() {\r\n      transformRect.remove();\r\n\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    // Draw selection box with transform points\r\n    let drawTransformBox = (rect) => {\r\n      const currentLayer = project.activeLayer;\r\n      this.UI_LAYER.activate();\r\n\r\n      if (rect) {\r\n        lastTransformRect = rect;\r\n      }\r\n\r\n      if (!lastTransformRect) {\r\n        currentLayer.activate();\r\n        return;\r\n      }\r\n\r\n      // Draw rect\r\n      transformRect = Path.Rectangle(lastTransformRect);\r\n      transformRect.strokeColor = \"black\";\r\n      transformRect.selectable = false;\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n\r\n      // Calculate the positions\r\n      var topLeftPt = lastTransformRect.point.subtract(transformBoxSize / 2);\r\n      var topMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n      var topRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var middleLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n      var middleRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height / 2\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      var bottomLeftPt = new Point(\r\n        lastTransformRect.point.x,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomMiddlePt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width / 2,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n      var bottomRightPt = new Point(\r\n        lastTransformRect.point.x + lastTransformRect.width,\r\n        lastTransformRect.point.y + lastTransformRect.height\r\n      ).subtract(transformBoxSize / 2);\r\n\r\n      // Calculate the boxes\r\n      var topLeftRect = new Rectangle(topLeftPt, transformBoxSize);\r\n      var topMiddleRect = new Rectangle(topMiddlePt, transformBoxSize);\r\n      var topRightRect = new Rectangle(topRightPt, transformBoxSize);\r\n\r\n      var middleLeftRect = new Rectangle(middleLeftPt, transformBoxSize);\r\n      var middleRightRect = new Rectangle(middleRightPt, transformBoxSize);\r\n\r\n      var bottomLeftRect = new Rectangle(bottomLeftPt, transformBoxSize);\r\n      var bottomMiddleRect = new Rectangle(bottomMiddlePt, transformBoxSize);\r\n      var bottomRightRect = new Rectangle(bottomRightPt, transformBoxSize);\r\n\r\n      // Assign the boxes\r\n      transformPoints.topLeft = Path.Rectangle(topLeftRect);\r\n      transformPoints.topMiddle = Path.Rectangle(topMiddleRect);\r\n      transformPoints.topRight = Path.Rectangle(topRightRect);\r\n\r\n      transformPoints.leftCenter = Path.Rectangle(middleLeftRect);\r\n      transformPoints.rightCenter = Path.Rectangle(middleRightRect);\r\n\r\n      transformPoints.bottomLeft = Path.Rectangle(bottomLeftRect);\r\n      transformPoints.bottomMiddle = Path.Rectangle(bottomMiddleRect);\r\n      transformPoints.bottomRight = Path.Rectangle(bottomRightRect);\r\n\r\n      // Set type\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].type = \"transformPoint\";\r\n        }\r\n      });\r\n\r\n      // Set cursor type\r\n      transformPoints.topLeft.cursorType = \"nw-resize\";\r\n      transformPoints.bottomRight.cursorType = \"nw-resize\";\r\n\r\n      transformPoints.topMiddle.cursorType = \"n-resize\";\r\n      transformPoints.bottomMiddle.cursorType = \"n-resize\";\r\n\r\n      transformPoints.topRight.cursorType = \"ne-resize\";\r\n      transformPoints.bottomLeft.cursorType = \"ne-resize\";\r\n\r\n      transformPoints.leftCenter.cursorType = \"e-resize\";\r\n      transformPoints.rightCenter.cursorType = \"e-resize\";\r\n\r\n      // Set names\r\n      transformPoints.topLeft.name = \"topLeft\";\r\n      transformPoints.topRight.name = \"topRight\";\r\n      transformPoints.topMiddle.name = \"topCenter\";\r\n\r\n      transformPoints.leftCenter.name = \"leftCenter\";\r\n      transformPoints.rightCenter.name = \"rightCenter\";\r\n\r\n      transformPoints.bottomLeft.name = \"bottomLeft\";\r\n      transformPoints.bottomMiddle.name = \"bottomCenter\";\r\n      transformPoints.bottomRight.name = \"bottomRight\";\r\n\r\n      // Set the box colors\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        if (transformPoints[point]) {\r\n          transformPoints[point].selectable = false;\r\n          transformPoints[point].strokeColor = \"blue\";\r\n          transformPoints[point].fillColor = \"white\";\r\n          transformPoints[point].strokeWidth = transformBoxWidth;\r\n        }\r\n      });\r\n\r\n      currentLayer.activate();\r\n    }\r\n\r\n    // Redraw the selection box with transform points\r\n    let updateTransformBox = (bounds) => {\r\n      hideTransformBox();\r\n\r\n      if(this.SELECTED.length > 0) {\r\n        if (bounds) {\r\n          drawTransformBox(bounds);\r\n        } else {\r\n          drawTransformBox();\r\n        }\r\n      }\r\n    }\r\n\r\n    // Hide the transform points, but keep the box (e.g. while moving selection)\r\n    function HideTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = false;\r\n      });\r\n    }\r\n\r\n    function ShowTransformPoints() {\r\n      Object.keys(transformPoints).forEach(function(point, index) {\r\n        transformPoints[point].visible = true;\r\n      });\r\n    }\r\n\r\n    function CreateSelectionRectanglePath({rect, strokeWidth, strokeColor, dashArray}) {\r\n      let path = Path.Rectangle(rect);\r\n      Object.assign(path, {\r\n        strokeWidth: strokeWidth,\r\n        strokeColor: strokeColor,\r\n        dashArray: dashArray,\r\n        selectable: false\r\n      });\r\n      return path;\r\n    }\r\n\r\n  //#region Group\r\n    let SelectGroup = (group) => {\r\n      if(!group.selected) {\r\n        let ungrouped = getUngrouped([group]);\r\n        for(let i=0; i<ungrouped.length; i++) {\r\n          ungrouped[i].selected = true;\r\n        }\r\n        group.selected = true;\r\n        this.ADD_SELECT(group);\r\n      }\r\n    }\r\n\r\n    function DeselectGroup(group) {\r\n      DeselectShape(group);\r\n    }\r\n\r\n    function CheckGroupIntersection(group, rect) {\r\n      // Check for every child in the group\r\n      let children = getUngrouped(group.children);\r\n      for (let j = 0; j < children.length; j++) {\r\n        console.log(\"child\")\r\n        // Check for intersection with selection rect\r\n        if (rect.intersects(children[j])) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckGroupInsideRect(group, rect) {\r\n      let children = getUngrouped(group.children);\r\n      for(let i=0; i<children.length; i++) {\r\n        if (children[i].isInside(rect) && children[i].selectable) {\r\n          return { success: true };\r\n        }\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n  //#region Shape\r\n    let SelectShape = (shape) => {\r\n      if (!shape.selected) {\r\n        shape.selected = true;\r\n        this.ADD_SELECT(shape);\r\n      }\r\n    }\r\n\r\n    let DeselectShape = (shape) => {\r\n      shape.selected = false;\r\n      let index = getSelection().findIndex(x => x === shape);\r\n      if (index != -1) {\r\n        getSelection().splice(index, 1);\r\n      }\r\n    }\r\n\r\n    function CheckShapeIntersection(shape, rectPath) {\r\n      // Selection rect intersects with the shape\r\n      if (rectPath.intersects(shape) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n\r\n    function CheckShapeInsideRect(shape, rect) {\r\n      // Shape is inside the selection rect\r\n      if (shape.isInside(rect) && shape.selectable) {\r\n        return { success: true };\r\n      }\r\n\r\n      return { success: false };\r\n    }\r\n  //\r\n\r\n    // Return the opposite point on the transform box\r\n    function getOppositePoint(point, x, y, bounds) {\r\n      if (!point) {\r\n        alert(\"warning: 001\");\r\n        return;\r\n      }\r\n      var _point = point;\r\n      var opposite = bounds.center.add(bounds.center.subtract(point));\r\n\r\n      if (x) {\r\n        _point = new Point(opposite.x, _point.y);\r\n      }\r\n      if (y) {\r\n        _point = new Point(_point.x, opposite.y);\r\n      }\r\n\r\n      return _point;\r\n    }\r\n\r\n    // Get the selection rectangle\r\n    let getBounds = (shapes) => {\r\n      if (shapes.length == 0) {\r\n        return null;\r\n      }\r\n\r\n      var _temp = [];\r\n      for (var i = 0; i < shapes.length; i++) {\r\n        let item = shapes[i];\r\n\r\n        if(item.type == \"group\") {\r\n          let ungrouped = getUngrouped(item.children);\r\n          for(let j=0; j<ungrouped.length; j++) {\r\n            _temp.push(ungrouped[j].clone());\r\n          }\r\n        }\r\n        else if(item.type == \"shape\") {\r\n          _temp.push(item.clone());\r\n        }\r\n      }\r\n\r\n      // Make a compoundpath to get the bounds for the transform box\r\n      var _grouped = new CompoundPath({\r\n        children: _temp\r\n      });\r\n\r\n      var rect = _grouped.bounds;\r\n      _grouped.remove();\r\n\r\n      return rect;\r\n    }\r\n\r\n    function RedrawTransformPoints() {\r\n      Object.keys(transformPoints).forEach((point, index) => {\r\n        transformPoints[point].position = transformRect.bounds[point];\r\n      });\r\n    }\r\n\r\n    // While scaling check whether the selection should be flipped\r\n    function checkScaleFlip() {\r\n      if (relH > 0 && flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = false;\r\n      } else if (relH < 0 && !flippedV && !lockScaleY) {\r\n        transform.scale_facH = -transform.scale_facH;\r\n        flippedV = true;\r\n      }\r\n\r\n      if (relW > 0 && !flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = true;\r\n      }\r\n      if (relW < 0 && flippedH && !lockScaleX) {\r\n        transform.scale_facW = -transform.scale_facW;\r\n        flippedH = false;\r\n      }\r\n    }\r\n\r\n    // Handle ctrl-key presses\r\n    function handleControlKey() {\r\n      var delta = initTransfData.center.subtract(transformRect.bounds.center);\r\n\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].translate(delta);\r\n      }\r\n\r\n      transformRect.position = initTransfData.center;\r\n      point = new Point(initTransfData.center.x, initTransfData.center.y);\r\n\r\n      action.scale.data.pivot = point;\r\n\r\n      mouseDrag(mouseEvent);\r\n    }\r\n//\r\n\r\n//#region Mouse down\r\n    \r\n    this.TOOLSELECT.onMouseDown = e => {\r\n      mouseDown = true;\r\n      _lastMousePos = e.point;\r\n\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n          state.isDragging = true;\r\n\r\n          // Hide scaling points when moving the selection\r\n          HideTransformPoints();\r\n          DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n          state.snapVecLeftX = getBounds(getSelection()).leftCenter.subtract(e.point);\r\n          state.snapVecRightX = getBounds(getSelection()).rightCenter.subtract(e.point);\r\n          state.snapVecTopY = getBounds(getSelection()).topCenter.subtract(e.point);\r\n          state.snapVecBottomY = getBounds(getSelection()).bottomCenter.subtract(e.point);\r\n\r\n          action.move = new Action(\"move\", {\r\n            paths: getUngrouped(getSelection()),\r\n            startPos: e.point,\r\n            endPos: null\r\n          });\r\n\r\n          return;\r\n        }\r\n      }\r\n\r\n      hideTransformBox();\r\n      if (state.isHovering && hoverItem.type == \"transformPoint\") {\r\n        let bounds = getBounds(getSelection());\r\n\r\n        state.isScaling = true;\r\n\r\n        // Hide scaling points when scaling the selection\r\n        HideTransformPoints();\r\n        DrawShadowPaths(getUngrouped(getSelection()));\r\n\r\n        drawTransformBox();\r\n\r\n        transform.dir = e.item.name;\r\n        point = getOppositePoint(bounds[transform.dir], true, true, bounds);\r\n\r\n        // Updating the backup data (for shift-scale and for undo)\r\n        initTransfData.width = bounds.width;\r\n        initTransfData.height = bounds.height;\r\n        initTransfData.pivot = new Point(point.x, point.y);\r\n        initTransfData.center = new Point(bounds.center.x, bounds.center.y);\r\n\r\n        switch (transform.dir) {\r\n          case \"bottomLeft\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topLeft\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomRight\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topRight\":\r\n            flippedV = true;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"bottomCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"topCenter\":\r\n            flippedV = true;\r\n            flippedH = false;\r\n            lockScaleX = true;\r\n            lockScaleY = false;\r\n            break;\r\n          case \"leftCenter\":\r\n            flippedV = false;\r\n            flippedH = false;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n          case \"rightCenter\":\r\n            flippedV = false;\r\n            flippedH = true;\r\n            lockScaleX = false;\r\n            lockScaleY = true;\r\n            break;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          handleControlKey();\r\n        }\r\n\r\n        action.scale = new Action(\"scale\", {\r\n          paths: getUngrouped(getSelection()),\r\n          pivot: initTransfData.pivot,\r\n          lockX: lockScaleX,\r\n          lockY: lockScaleY,\r\n          handle_init: bounds[transform.dir],\r\n          handle_end: null,\r\n          shift: false\r\n        });\r\n\r\n        mouseDrag(e);\r\n\r\n        return;\r\n      }\r\n\r\n      transformRect = new Path();\r\n\r\n      // Mouse is not over a shape\r\n      if (!state.isHovering) {\r\n        this.DESELECT();\r\n      }\r\n\r\n      // Mouse is over a shape\r\n      if (hoverSelection) {\r\n        hoverSelection.remove();\r\n\r\n        if (hoverItem && !hoverItem.selected && hoverItem.selectable) {\r\n          // Shift key is pressed\r\n          if (e.modifiers.shift) {\r\n            hoverItem.selected = true;\r\n\r\n            this.ADD_SELECT(hoverItem);\r\n          }\r\n          // Shift key is not pressed\r\n          else {\r\n            project.deselectAll();\r\n\r\n            this.DESELECT();\r\n\r\n            SelectShape(hoverItem);\r\n          }\r\n\r\n          drawTransformBox(getBounds(getSelection()));\r\n        }\r\n      }\r\n\r\n      if (!e.item) {\r\n        project.deselectAll();\r\n        this.DESELECT();\r\n        selectRectAnchor = e.point;\r\n        state.isSelecting = true;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse move\r\n    this.TOOLSELECT.onMouseMove = (e) => {\r\n      mouseEvent = e;\r\n\r\n      // Reset cursor style\r\n      document.body.style.cursor = \"default\";\r\n      ResetHover();\r\n\r\n      // Mouse is hovering over an item\r\n      if (e.item && !state.isSelecting && !state.isDragging) {\r\n\r\n        if (e.item.selectable) {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverPath(hoverItem);\r\n        }\r\n        \r\n        // Mouse is hovering over transform-handle (not selectable)\r\n        else if(e.item.type == \"transformPoint\") {\r\n          hoverItem = e.item;\r\n          state.isHovering = true;\r\n          HandleMouseHoverTransform(hoverItem);\r\n        }\r\n      }\r\n\r\n      if (state.isSelecting && !state.isHovering) {\r\n        selectRectPath.remove();\r\n\r\n        let selectRect = new Rectangle(selectRectAnchor, e.point);\r\n\r\n        selectRectPath = CreateSelectionRectanglePath({\r\n          rect: selectRect,\r\n          strokeWidth: 0.5 / view.zoom,\r\n          strokeColor: \"black\",\r\n          dashArray: [4 / view.zoom, 3 / view.zoom]\r\n        });\r\n\r\n        let objects = this.OBJECTS;\r\n        for (let i = 0; i < objects.length; i++) {\r\n          /* First, check for intersections between the shapes and the selection rectangle,\r\n            if none, check whether the shapes are inside the rectangle */\r\n            \r\n          let obj = objects[i];\r\n\r\n          // Group\r\n          if (obj.type == \"group\" && obj.selectable) {\r\n            console.log(\"checking group\")\r\n            let _isIntersect = CheckGroupIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectGroup(obj);\r\n            else {\r\n              let _isInside = CheckGroupInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectGroup(obj);\r\n              else {\r\n                DeselectGroup(obj);\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Shape\r\n          else if (obj.type == \"shape\") {\r\n            let _isIntersect = CheckShapeIntersection(obj, selectRectPath);\r\n\r\n            if(_isIntersect.success)\r\n              SelectShape(obj);\r\n            else {\r\n              let _isInside = CheckShapeInsideRect(obj, selectRect);\r\n\r\n              if(_isInside.success)\r\n                SelectShape(obj);\r\n              else {\r\n                DeselectShape(obj);\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n      }\r\n      if (this.SELECTED.length != 0) {\r\n        if (e.point.isInside(transformRect.bounds) && !state.isScaling) {\r\n          document.body.style.cursor = \"move\";\r\n        }\r\n      }\r\n\r\n      // Call mouseDrag AFTER mouseMove\r\n      if (mouseDown) {\r\n        mouseDrag(e);\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse up\r\n    this.TOOLSELECT.onMouseUp = e => {\r\n      mouseDown = false;\r\n      var _return = false;\r\n\r\n      selectRectAnchor = null;\r\n      state.isSelecting = false;\r\n      selectRectPath.remove();\r\n\r\n      if (getSelection().length == 0) {\r\n        return;\r\n      }\r\n\r\n      if (state.isScaling) {\r\n        lockScaleX = false;\r\n        lockScaleY = false;\r\n\r\n        let bounds = getBounds(getSelection());\r\n\r\n        action.scale.data.handle_end = getOppositePoint(\r\n          point,\r\n          true,\r\n          true,\r\n          bounds\r\n        );\r\n        if (e.modifiers.shift) {\r\n          action.scale.data.shift = true;\r\n        }\r\n        if(e.modifiers.control) {\r\n          action.scale.data.handle_end = transformRect.bounds[transform.dir];\r\n          action.scale.data.pivot = new Point(initTransfData.center.x, initTransfData.center.y);\r\n        }\r\n        this.ADD_ACTION(action.scale);\r\n\r\n        state.isScaling = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if (state.isDragging) {\r\n        action.move.data.endPos = e.point;\r\n        this.ADD_ACTION(action.move);\r\n\r\n        state.isDragging = false;\r\n\r\n        // Scaling points where hidden while moving selection\r\n        ShowTransformPoints();\r\n        RemoveShadowPaths();\r\n\r\n        _return = true;\r\n\r\n        // Update the guide-points\r\n        this.updateGuidePoints();\r\n      }\r\n\r\n      if(this.snappedX)\r\n        this.clearGuideLinesX();\r\n      if(this.snappedY)\r\n        this.clearGuideLinesY();\r\n\r\n      // Update transform box with new rectangle\r\n      hideTransformBox();\r\n      drawTransformBox(getBounds(getSelection()));\r\n\r\n      if (_return) {\r\n        return;\r\n      }\r\n    };\r\n//\r\n\r\n//#region Mouse drag\r\n    let mouseDrag = (e) => {\r\n      mouseDelta = e.point.subtract(_lastMousePos);\r\n      if(Data.SNAP_MOVE && state.isDragging) {\r\n        let snapY = null;\r\n        let snapX = null;\r\n\r\n        // Snapping y-axis\r\n        if(mouseDelta.y != 0) {\r\n          let snappedY = false;\r\n\r\n          // Check for top snap\r\n          let guided, _;\r\n          [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecTopY))\r\n          mouseDelta.y = guided.subtract(transformRect.bounds.topCenter).y;\r\n\r\n          if(snappedY) {\r\n            snapY = guided.y;\r\n          }\r\n          //If top hasn't snapped, check for bottom snap\r\n          else {\r\n            [guided, _, snappedY] = this.getGuidedPosition(e.point.add(state.snapVecBottomY));\r\n            mouseDelta.y = guided.subtract(transformRect.bounds.bottomCenter).y;\r\n\r\n            if(snappedY) {\r\n              snapY = guided.y;\r\n            }\r\n          }\r\n\r\n          // If snapped to a y-line, display the line\r\n          if (snapY != null) {\r\n            this.drawGuideLines(null, [snapY]);\r\n            this.snappedY = true;\r\n          }\r\n          else if(this.snappedY) {\r\n            this.snappedY = false;\r\n            this.clearGuideLinesY();\r\n          }\r\n        }\r\n\r\n        // Snapping x-axis\r\n        if(mouseDelta.x != 0) {\r\n          let snappedX = false;\r\n\r\n          // Check for left snap\r\n          let guided, _;\r\n          [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecLeftX));\r\n          mouseDelta.x = guided.subtract(transformRect.bounds.leftCenter).x;\r\n\r\n          if(snappedX) {\r\n            snapX = guided.x;\r\n          }\r\n          // If left hasn't snapped, check for right snap\r\n          else {\r\n            [guided, snappedX, _] = this.getGuidedPosition(e.point.add(state.snapVecRightX));\r\n            mouseDelta.x = guided.subtract(transformRect.bounds.rightCenter).x;\r\n\r\n            if(snappedX) {\r\n              snapX = guided.x;\r\n            }\r\n          }\r\n\r\n          // If snapped to a x-line, display the line\r\n          if (snapX != null) {\r\n            this.drawGuideLines([snapX], null);\r\n            this.snappedX = true;\r\n          }\r\n          else if(this.snappedX) {\r\n            this.snappedX = false;\r\n            this.clearGuideLinesX();\r\n          }\r\n        }\r\n      }\r\n\r\n      _lastMousePos = e.point;\r\n\r\n      var path = transformRect;\r\n\r\n      // User is moving the selection\r\n      if (state.isDragging) {\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(mouseDelta);\r\n        }\r\n\r\n        transformRect.translate(mouseDelta);\r\n        lastTransformRect = transformRect.bounds;\r\n\r\n        Object.keys(transformPoints).forEach(function(point, index) {\r\n          transformPoints[point].translate(mouseDelta);\r\n        });\r\n        return;\r\n      }\r\n\r\n      // User is scaling the selection\r\n      if (state.isScaling) {\r\n        // Add snapping if enabled\r\n        if(Data.SNAP_SCALE) {\r\n          if(Math.abs(transform.scale_facH) > 0.1 && Math.abs(transform.scale_facW) > 0.1) {\r\n            let [guided, xsnapped, ysnapped] = this.getGuidedPosition(e.point);\r\n            if (xsnapped) {\r\n              this.drawGuideLines([guided.x], null);\r\n              this.snappedX = true;\r\n            }\r\n            else if(this.snappedX) {\r\n              this.snappedX = false;\r\n              this.clearGuideLinesX();\r\n            }\r\n            if (ysnapped) {\r\n              this.drawGuideLines(null, [guided.y]);\r\n              this.snappedY = true;\r\n            }\r\n            else if(this.snappedY) {\r\n              this.snappedY = false;\r\n              this.clearGuideLinesY();\r\n            }\r\n\r\n            e.point = guided;\r\n          }\r\n        }\r\n        \r\n        let bounds = transformRect.bounds;\r\n\r\n        if (!lockScaleY) {\r\n          relH = e.point.subtract(point).y;\r\n          transform.scale_facH = Math.abs(relH) / bounds.height;\r\n        } else {\r\n          transform.scale_facH = 1;\r\n        }\r\n        if (!lockScaleX) {\r\n          relW = e.point.subtract(point).x;\r\n          transform.scale_facW = Math.abs(relW) / bounds.width;\r\n        } else {\r\n          transform.scale_facW = 1;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facH) < 0.1 && !lockScaleY) {\r\n          return;\r\n        }\r\n\r\n        if (Math.abs(transform.scale_facW) < 0.1 && !lockScaleX) {\r\n          return;\r\n        }\r\n\r\n        if (!e.modifiers.shift) {\r\n          checkScaleFlip();\r\n        }\r\n\r\n        if (e.modifiers.shift) {\r\n          var min = Math.min(\r\n            Math.abs(transform.scale_facH),\r\n            Math.abs(transform.scale_facW)\r\n          );\r\n\r\n          if (lockScaleY) {\r\n            min = Math.abs(transform.scale_facW);\r\n          } else if (lockScaleX) {\r\n            min = Math.abs(transform.scale_facH);\r\n          }\r\n\r\n          transform.scale_facH = min;\r\n          transform.scale_facW = min;\r\n        }\r\n\r\n        if (e.modifiers.control) {\r\n          if (!lockScaleX) {\r\n            transform.scale_facW *= 2;\r\n          }\r\n          if (!lockScaleY) {\r\n            transform.scale_facH *= 2;\r\n          }\r\n        }\r\n\r\n        // Scale all the selected items\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(\r\n            transform.scale_facW,\r\n            transform.scale_facH,\r\n            point\r\n          );\r\n        }\r\n\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        // Don't show the points while scaling\r\n        Object.keys(transformPoints).forEach((point, index) => {\r\n          transformPoints[point].remove();\r\n        });\r\n      }\r\n    }\r\n//\r\n\r\n//#region events\r\n    // - user is zooming -\r\n    bus.$on(\"zoom\", () => {\r\n      // Keep the transform box's width constant over zoom\r\n      transformRect.strokeWidth = 0.5 / view.zoom;\r\n      transformBoxSize = 7 / view.zoom;\r\n      transformBoxWidth = 2 / view.zoom;\r\n\r\n      if (getSelection().length > 0) {\r\n        updateTransformBox();\r\n      }\r\n    });\r\n\r\n    // - Ctrl + Z -\r\n    bus.$on(\"undo\", () => {\r\n      if (this.ACTIONS.length > 0) {\r\n        this.UNDO();\r\n\r\n        project.deselectAll();\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].selected = true;\r\n        }\r\n\r\n        this.updateGuidePoints();\r\n\r\n        if(this.ACTIVE_TOOL == 'select') {\r\n          updateTransformBox(getBounds(getSelection()));\r\n        }\r\n      }\r\n    });\r\n\r\n    // - Ctrl + Shift + Z -\r\n    bus.$on(\"redo\", () => {\r\n      if (this.REDO_ACTIONS.length > 0) {\r\n        this.REDO();\r\n\r\n        project.deselectAll();\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].selected = true;\r\n        }\r\n\r\n        this.updateGuidePoints();\r\n\r\n        if(this.ACTIVE_TOOL == 'select') {\r\n          updateTransformBox(getBounds(getSelection()));\r\n        }\r\n      }\r\n    });\r\n\r\n    // - delete key pressed -\r\n    bus.$on(\"delete_selection\", () => {\r\n      this.DESELECT();\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - shift key pressed -\r\n    bus.$on(\"shift\", () => {\r\n      if (state.isScaling) {\r\n        var bounds = getBounds(getSelection());\r\n\r\n        var facH_init = initTransfData.height / bounds.height;\r\n        var facW_init = initTransfData.width / bounds.width;\r\n\r\n        // Scale the selection to its initial size\r\n        let selection = getUngrouped(getSelection());\r\n\r\n        var rel;\r\n\r\n        if (lockScaleX) {\r\n          rel = Math.abs(relH);\r\n        } else if (lockScaleY) {\r\n          rel = Math.abs(relW);\r\n        } else {\r\n          rel = Math.min(Math.abs(relH), Math.abs(relW));\r\n        }\r\n\r\n        var fac = rel / Math.min(initTransfData.width, initTransfData.height);\r\n\r\n        transform.scale_facW = facW_init * fac;\r\n        transform.scale_facH = facH_init * fac;\r\n\r\n        // Resize the selection to the current size without deformation\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(transform.scale_facW, transform.scale_facH, point);\r\n        }\r\n\r\n        // Resize transform rect as well\r\n        transformRect.scale(transform.scale_facW, transform.scale_facH, point);\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    // - control key pressed -\r\n    bus.$on(\"control\", () => {\r\n      if (state.isScaling) {\r\n        handleControlKey();\r\n      }\r\n    });\r\n\r\n    // - control key released -\r\n    bus.$on(\"control_up\", () => {\r\n      if (state.isScaling) {\r\n        point = new Point(initTransfData.pivot.x, initTransfData.pivot.y);\r\n        action.scale.data.pivot = point;\r\n\r\n        relH = mouseEvent.point.subtract(point).y;\r\n        relW = mouseEvent.point.subtract(point).x;\r\n\r\n        var curDistPt;\r\n\r\n        if (relH >= 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.topLeft;\r\n          flippedV = false;\r\n          flippedH = true;\r\n        } else if (relH >= 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.topRight;\r\n          flippedV = false;\r\n          flippedH = false;\r\n        } else if (relH < 0 && relW >= 0) {\r\n          curDistPt = transformRect.bounds.bottomLeft;\r\n          flippedV = true;\r\n          flippedH = true;\r\n        } else if (relH < 0 && relW < 0) {\r\n          curDistPt = transformRect.bounds.bottomRight;\r\n          flippedV = true;\r\n          flippedH = false;\r\n        }\r\n\r\n        var delta = initTransfData.pivot.subtract(curDistPt);\r\n        if (lockScaleX) {\r\n          delta.x = 0;\r\n        } else if (lockScaleY) {\r\n          delta.y = 0;\r\n        }\r\n\r\n        transformRect.translate(delta);\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].translate(delta);\r\n        }\r\n\r\n        mouseDrag(mouseEvent);\r\n      }\r\n    });\r\n\r\n    bus.$on(\"hide-transformbox\", () => {\r\n      hideTransformBox();\r\n    });\r\n\r\n    // - switched to another tool -\r\n    bus.$on(\"deactivate-select\", () => {\r\n      for (var i = 0; i < getSelection().length; i++) {\r\n        DeselectShape(getSelection());\r\n      }\r\n\r\n      if (this.ACTIVE_TOOL != \"pointer\") {\r\n        this.DESELECT();\r\n      }\r\n\r\n      hideTransformBox();\r\n    });\r\n\r\n    bus.$on(\"activate-select\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        for (var i = 0; i < getSelection().length; i++) {\r\n          SelectShape(getSelection()[i]);\r\n        }\r\n\r\n        // There could've been drawn a new shape\r\n        this.updateGuidePoints();\r\n\r\n        drawTransformBox(getBounds(getSelection()));\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_stroke\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_color_fill\", color => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].fillColor = color;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_width_stroke\", width => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeWidth = width;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_cap_stroke\", type => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].strokeCap = type;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"set_opacity\", opacity => {\r\n      let selection = getUngrouped(getSelection());\r\n      for (var i = 0; i < selection.length; i++) {\r\n        selection[i].opacity = opacity/100;\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-hor\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        let selection = getUngrouped(getSelection());\r\n        for (var i = 0; i < selection.length; i++) {\r\n          selection[i].scale(1, -1, center);\r\n        }\r\n      }\r\n    });\r\n\r\n    bus.$on(\"flip-ver\", () => {\r\n      if (this.SELECTED.length > 0) {\r\n        let bounds = getBounds(getSelection());\r\n        var center = bounds.center;\r\n\r\n        for (var i = 0; i < this.SELECTED.length; i++) {\r\n          this.SELECTED[i].scale(-1, 1, center);\r\n        }\r\n      }\r\n    });\r\n//\r\n\r\n//#region Aligning\r\n\r\n  // Horizontal\r\n  bus.$on('align-hor-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_x = Data.CENTER_HOR - bounds.center.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n    // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(dist_x, 0))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n\r\n  bus.$on('align-hor-left', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docLeft = Data.CENTER_HOR - Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docLeft - bounds.x;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n    // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(dist_x, 0))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n\r\n  bus.$on('align-hor-right', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docRight = Data.CENTER_HOR + Data.DOCUMENT_WIDTH/2;\r\n    let dist_x = docRight - (bounds.x + bounds.width);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([dist_x, 0]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n    // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(dist_x, 0))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n\r\n\r\n  // Vertical\r\n  bus.$on('align-ver-center', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let dist_y = Data.CENTER_VER - bounds.center.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n    // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(0, dist_y))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n\r\n  bus.$on('align-ver-top', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER - Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - bounds.y;\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n        // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(0, dist_y))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n\r\n  bus.$on('align-ver-bottom', () => {\r\n    let selection = getSelection();\r\n    let bounds = getBounds(selection);\r\n    let docTop = Data.CENTER_VER + Data.DOCUMENT_HEIGHT/2;\r\n    let dist_y = docTop - (bounds.y + bounds.height);\r\n\r\n    let ungrouped = getUngrouped(selection);\r\n    for(let i=0; i<ungrouped.length; i++) {\r\n      ungrouped[i].translate([0, dist_y]);\r\n    }\r\n\r\n    updateTransformBox(getBounds(getSelection()));\r\n\r\n        // Make undo-abel\r\n    action.move = new Action(\"move\", {\r\n      paths: ungrouped,\r\n      startPos: bounds.center,\r\n      endPos: bounds.center.add(new Point(0, dist_y))\r\n    });\r\n\r\n    this.ADD_ACTION(action.move);\r\n  });\r\n//\r\n  }\r\n};\r\n</script>\r\n\r\n\r\n\r\n\r\n\r\n<style scoped>\r\n</style>"],"sourceRoot":"src/components/tools"}]}