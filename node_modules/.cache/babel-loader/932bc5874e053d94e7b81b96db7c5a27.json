{"remainingRequest":"D:\\GitHub\\Vectory\\vectory\\node_modules\\babel-loader\\lib\\index.js!D:\\GitHub\\Vectory\\vectory\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\GitHub\\Vectory\\vectory\\src\\libraries\\node\\extend.js","dependencies":[{"path":"D:\\GitHub\\Vectory\\vectory\\src\\libraries\\node\\extend.js","mtime":1552939656894},{"path":"D:\\GitHub\\Vectory\\vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\vectory\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Date$now from \"D:\\\\GitHub\\\\Vectory\\\\vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/date/now\";\n\n/*\n * Paper.js - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & https://puckey.studio/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n */\nvar fs = require('fs'),\n    path = require('path');\n\nmodule.exports = function (paper) {\n  if (paper.PaperScript) {\n    var sourceMapSupport = 'require(\"source-map-support\").install(paper.PaperScript.sourceMapSupport);\\n',\n        sourceMaps = {};\n    paper.PaperScript.sourceMapSupport = {\n      retrieveSourceMap: function retrieveSourceMap(source) {\n        var map = sourceMaps[source];\n        return map ? {\n          url: source,\n          map: map\n        } : null;\n      }\n    }; // Register the .pjs extension for automatic compilation as PaperScript\n\n    require.extensions['.pjs'] = function (module, filename) {\n      // Requiring a PaperScript on Node.js returns an initialize method which\n      // needs to receive a Canvas object when called and returns the\n      // PaperScope.\n      module.exports = function (canvas) {\n        var source = fs.readFileSync(filename, 'utf8'),\n            code = sourceMapSupport + source,\n            compiled = paper.PaperScript.compile(code, {\n          url: filename,\n          source: source,\n          sourceMaps: true,\n          offset: -1 // remove sourceMapSupport...\n\n        }),\n            scope = new paper.PaperScope(); // Keep track of sourceMaps so retrieveSourceMap() can link them up\n\n        scope.setup(canvas);\n        scope.__filename = filename;\n        scope.__dirname = path.dirname(filename); // Expose core methods and values\n\n        scope.require = require;\n        scope.console = console;\n        sourceMaps[filename] = compiled.map;\n        paper.PaperScript.execute(compiled, scope);\n        return scope;\n      };\n    };\n  }\n\n  paper.PaperScope.inject({\n    createCanvas: function createCanvas(width, height, type) {\n      // Do not use CanvasProvider.getCanvas(), since we may be changing\n      // the underlying node-canvas when requesting PDF support, and don't\n      // want to release it after back into the pool.\n      var canvas = paper.document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      canvas.type = type;\n      return canvas;\n    },\n\n    /**\n     * @deprecated, use use {@link #createCanvas(width, height)} instead.\n     */\n    Canvas: '#createCanvas'\n  }); // Override requestAnimationFrame() to avoid setInterval() timers.\n  // NOTE: In Node.js, we only support manual updating for now, but\n  // View#exportFrames() below offers a way to emulate animations by exporting\n  // them frame by frame at the given frame-rate.\n\n  paper.DomEvent.requestAnimationFrame = function (callback) {}; // Node.js based image exporting code.\n\n\n  paper.CanvasView.inject({\n    // DOCS: CanvasView#exportFrames(options);\n    exportFrames: function exportFrames(options) {\n      options = paper.Base.set({\n        fps: 30,\n        prefix: 'frame-',\n        amount: 1,\n        format: 'png' // Supported: 'png' or 'jpeg'\n\n      }, options);\n      if (!options.directory) throw new Error('Missing options.directory');\n      if (options.format && !/^(jpeg|png)$/.test(options.format)) throw new Error('Unsupported format. Use \"png\" or \"jpeg\"');\n\n      var view = this,\n          count = 0,\n          frameDuration = 1 / options.fps,\n          startTime = _Date$now(),\n          lastTime = startTime,\n          padding = options.padding || (options.amount - 1 + '').length,\n          paddedStr = Array(padding + 1).join('0'); // Start exporting frames by exporting the first frame:\n\n\n      exportFrame(options);\n\n      function exportFrame() {\n        // Convert to a Base object, for #toString()\n        view.emit('frame', new paper.Base({\n          delta: frameDuration,\n          time: frameDuration * count,\n          count: count\n        }));\n        var file = path.join(options.directory, options.prefix + (paddedStr + count).slice(-padding) + '.' + options.format);\n        var out = view.exportImage(file, function () {\n          // Once the file has been closed, export the next fame:\n          var then = _Date$now();\n\n          if (options.onProgress) {\n            options.onProgress({\n              count: count,\n              amount: options.amount,\n              percentage: Math.round((count + 1) / options.amount * 10000) / 100,\n              time: then - startTime,\n              delta: then - lastTime\n            });\n          }\n\n          lastTime = then;\n\n          if (++count < options.amount) {\n            exportFrame();\n          } else {\n            // Call onComplete handler when finished:\n            if (options.onComplete) {\n              options.onComplete();\n            }\n          }\n        });\n      }\n    },\n    // DOCS: CanvasView#exportImage(path, callback);\n    exportImage: function exportImage(path, callback) {\n      this.update();\n\n      var out = fs.createWriteStream(path),\n          format = /\\.jp(e?)g$/.test(path) ? 'jpeg' : 'png',\n          stream = this._element[format + 'Stream']();\n\n      stream.pipe(out);\n\n      if (callback) {\n        out.on('close', callback);\n      }\n\n      return out;\n    }\n  });\n};",{"version":3,"sources":["D:\\GitHub\\Vectory\\vectory\\src\\libraries\\node\\extend.js"],"names":["fs","require","path","module","exports","paper","PaperScript","sourceMapSupport","sourceMaps","retrieveSourceMap","source","map","url","extensions","filename","canvas","readFileSync","code","compiled","compile","offset","scope","PaperScope","setup","__filename","__dirname","dirname","console","execute","inject","createCanvas","width","height","type","document","createElement","Canvas","DomEvent","requestAnimationFrame","callback","CanvasView","exportFrames","options","Base","set","fps","prefix","amount","format","directory","Error","test","view","count","frameDuration","startTime","lastTime","padding","length","paddedStr","Array","join","exportFrame","emit","delta","time","file","slice","out","exportImage","then","onProgress","percentage","Math","round","onComplete","update","createWriteStream","stream","_element","pipe","on"],"mappings":"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","sourcesContent":["/*\n * Paper.js - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & https://puckey.studio/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n */\n\nvar fs = require('fs'),\n    path = require('path');\n\nmodule.exports = function(paper) {\n    if (paper.PaperScript) {\n        var sourceMapSupport = 'require(\"source-map-support\").install(paper.PaperScript.sourceMapSupport);\\n',\n            sourceMaps = {};\n\n        paper.PaperScript.sourceMapSupport = {\n            retrieveSourceMap: function(source) {\n                var map = sourceMaps[source];\n                return map ? { url: source, map: map } : null;\n            }\n        };\n\n        // Register the .pjs extension for automatic compilation as PaperScript\n        require.extensions['.pjs'] = function(module, filename) {\n            // Requiring a PaperScript on Node.js returns an initialize method which\n            // needs to receive a Canvas object when called and returns the\n            // PaperScope.\n            module.exports = function(canvas) {\n                var source = fs.readFileSync(filename, 'utf8'),\n                    code = sourceMapSupport + source,\n                    compiled = paper.PaperScript.compile(code, {\n                        url: filename,\n                        source: source,\n                        sourceMaps: true,\n                        offset: -1 // remove sourceMapSupport...\n                    }),\n                    scope = new paper.PaperScope();\n                // Keep track of sourceMaps so retrieveSourceMap() can link them up\n                scope.setup(canvas);\n                scope.__filename = filename;\n                scope.__dirname = path.dirname(filename);\n                // Expose core methods and values\n                scope.require = require;\n                scope.console = console;\n                sourceMaps[filename] = compiled.map;\n                paper.PaperScript.execute(compiled, scope);\n                return scope;\n            };\n        };\n    }\n\n    paper.PaperScope.inject({\n        createCanvas: function(width, height, type) {\n            // Do not use CanvasProvider.getCanvas(), since we may be changing\n            // the underlying node-canvas when requesting PDF support, and don't\n            // want to release it after back into the pool.\n            var canvas = paper.document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            canvas.type = type;\n            return canvas;\n        },\n\n        /**\n         * @deprecated, use use {@link #createCanvas(width, height)} instead.\n         */\n        Canvas: '#createCanvas'\n    });\n\n    // Override requestAnimationFrame() to avoid setInterval() timers.\n    // NOTE: In Node.js, we only support manual updating for now, but\n    // View#exportFrames() below offers a way to emulate animations by exporting\n    // them frame by frame at the given frame-rate.\n    paper.DomEvent.requestAnimationFrame = function(callback) {\n    };\n\n    // Node.js based image exporting code.\n    paper.CanvasView.inject({\n        // DOCS: CanvasView#exportFrames(options);\n        exportFrames: function(options) {\n            options = paper.Base.set({\n                fps: 30,\n                prefix: 'frame-',\n                amount: 1,\n                format: 'png' // Supported: 'png' or 'jpeg'\n            }, options);\n            if (!options.directory)\n                throw new Error('Missing options.directory');\n            if (options.format && !/^(jpeg|png)$/.test(options.format))\n                throw new Error('Unsupported format. Use \"png\" or \"jpeg\"');\n            var view = this,\n                count = 0,\n                frameDuration = 1 / options.fps,\n                startTime = Date.now(),\n                lastTime = startTime,\n                padding = options.padding || ((options.amount - 1) + '').length,\n                paddedStr = Array(padding + 1).join('0');\n\n            // Start exporting frames by exporting the first frame:\n            exportFrame(options);\n\n            function exportFrame() {\n                // Convert to a Base object, for #toString()\n                view.emit('frame', new paper.Base({\n                    delta: frameDuration,\n                    time: frameDuration * count,\n                    count: count\n                }));\n                var file = path.join(options.directory,\n                        options.prefix + (paddedStr + count).slice(-padding)\n                            + '.' + options.format);\n                var out = view.exportImage(file, function() {\n                    // Once the file has been closed, export the next fame:\n                    var then = Date.now();\n                    if (options.onProgress) {\n                        options.onProgress({\n                            count: count,\n                            amount: options.amount,\n                            percentage: Math.round((count + 1) / options.amount\n                                    * 10000) / 100,\n                            time: then - startTime,\n                            delta: then - lastTime\n                        });\n                    }\n                    lastTime = then;\n                    if (++count < options.amount) {\n                        exportFrame();\n                    } else {\n                        // Call onComplete handler when finished:\n                        if (options.onComplete) {\n                            options.onComplete();\n                        }\n                    }\n                });\n            }\n        },\n\n        // DOCS: CanvasView#exportImage(path, callback);\n        exportImage: function(path, callback) {\n            this.update();\n            var out = fs.createWriteStream(path),\n                format = /\\.jp(e?)g$/.test(path) ? 'jpeg' : 'png',\n                stream = this._element[format + 'Stream']();\n            stream.pipe(out);\n            if (callback) {\n                out.on('close', callback);\n            }\n            return out;\n        }\n    });\n};\n"]}]}