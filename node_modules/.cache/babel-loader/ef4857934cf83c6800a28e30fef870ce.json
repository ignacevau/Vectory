{"remainingRequest":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js!D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\GitHub\\Vectory\\src\\mixins\\BooleanOperations.js","dependencies":[{"path":"D:\\GitHub\\Vectory\\src\\mixins\\BooleanOperations.js","mtime":1580471829874},{"path":"D:\\GitHub\\Vectory\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\GitHub\\Vectory\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _toConsumableArray from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"D:\\\\GitHub\\\\Vectory\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\nimport { mapState, mapMutations } from \"vuex\";\nimport paper from 'paper';\nimport Utils from '@/Utils.js';\nimport Data from '@/Data.js';\nimport { GroupOperations } from '@/mixins/GroupOperations.js';\nexport var BooleanOperations = {\n  mixins: [GroupOperations],\n  computed: _objectSpread({}, mapState(['SELECTED'])),\n  methods: _objectSpread({}, mapMutations(['DELETE_SHAPES', 'ADD_SHAPE']), {\n    UNITE: function UNITE() {\n      var shapes1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var shapes2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var items1,\n          items2 = null;\n\n      if (shapes1 == null && shapes2 == null) {\n        var length = this.SELECTED.length;\n\n        if (length >= 2) {\n          shapes1 = this.SELECTED[length - 1];\n          shapes2 = this.SELECTED[length - 2];\n        } else {\n          return;\n        }\n      } else if (shapes1 == null || shapes2 == null) {\n        return;\n      }\n\n      if (shapes1.type == \"group\") items1 = this.GET_UNGROUPED([shapes1]);else if (shapes1.type == \"shape\") items1 = [shapes1];else console.error(\"fuck you messed up! Unknown item type: \" + shapes1.type);\n      if (shapes2.type == \"group\") items2 = this.GET_UNGROUPED([shapes2]);else if (shapes2.type == \"shape\") items2 = [shapes2];else console.error(\"fuck you messed up! Unknown item type: \" + shapes2.type);\n      var junk = [].concat(_toConsumableArray(items1), _toConsumableArray(items2));\n      var result = items1[0].unite(items2[0]);\n      junk.push(result);\n\n      for (var i = 1; i < items1.length; i++) {\n        result = result.unite(items1[i]);\n        junk.push(result);\n      }\n\n      for (var _i = 1; _i < items2.length; _i++) {\n        result = result.unite(items2[_i]);\n        junk.push(result);\n      }\n\n      junk.pop();\n      this.DELETE_SHAPES({\n        shapes: junk,\n        undo: false\n      });\n      result.selectable = true;\n      result.type = \"shape\";\n      this.ADD_SHAPE(result);\n    }\n  })\n};",{"version":3,"sources":["D:\\GitHub\\Vectory\\src\\mixins\\BooleanOperations.js"],"names":["mapState","mapMutations","paper","Utils","Data","GroupOperations","BooleanOperations","mixins","computed","methods","UNITE","shapes1","shapes2","items1","items2","length","SELECTED","type","GET_UNGROUPED","console","error","junk","result","unite","push","i","pop","DELETE_SHAPES","shapes","undo","selectable","ADD_SHAPE"],"mappings":"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","sourcesContent":["import { mapState, mapMutations } from \"vuex\";\r\nimport paper from 'paper';\r\nimport Utils from '@/Utils.js';\r\nimport Data from '@/Data.js';\r\nimport { GroupOperations } from '@/mixins/GroupOperations.js';\r\n\r\nexport const BooleanOperations = {\r\n    mixins: [\r\n        GroupOperations\r\n    ],\r\n    computed: {\r\n        ...mapState([\r\n            'SELECTED'\r\n        ])\r\n    },\r\n    methods: {\r\n        ...mapMutations([\r\n            'DELETE_SHAPES',\r\n            'ADD_SHAPE'\r\n        ]),\r\n        UNITE: function (shapes1 = null, shapes2 = null) {\r\n            let items1, items2 = null;\r\n\r\n            if (shapes1 == null && shapes2 == null) {\r\n                let length = this.SELECTED.length;\r\n                if (length >= 2) {\r\n                    shapes1 = this.SELECTED[length-1];\r\n                    shapes2 = this.SELECTED[length-2];\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            else if (shapes1 == null || shapes2 == null) {\r\n                return;\r\n            }\r\n\r\n            if(shapes1.type == \"group\")\r\n                items1 = this.GET_UNGROUPED([shapes1]);\r\n            else if (shapes1.type == \"shape\")\r\n                items1 = [shapes1];\r\n            else\r\n                console.error(\"fuck you messed up! Unknown item type: \" + shapes1.type);\r\n\r\n            if (shapes2.type == \"group\")\r\n                items2 = this.GET_UNGROUPED([shapes2]);\r\n            else if(shapes2.type == \"shape\")\r\n                items2 = [shapes2];\r\n            else   \r\n                console.error(\"fuck you messed up! Unknown item type: \" + shapes2.type);\r\n\r\n            let junk = [...items1, ...items2];\r\n\r\n            let result = items1[0].unite(items2[0]);\r\n            junk.push(result);\r\n            for(let i=1; i<items1.length; i++) {\r\n                result = result.unite(items1[i])\r\n                junk.push(result);\r\n            }\r\n            for(let i=1; i<items2.length; i++) {\r\n                result = result.unite(items2[i])\r\n                junk.push(result);\r\n            }\r\n            junk.pop();\r\n\r\n            this.DELETE_SHAPES({\r\n                shapes: junk,\r\n                undo: false\r\n            });\r\n\r\n            result.selectable = true;\r\n            result.type = \"shape\";\r\n            this.ADD_SHAPE(result);\r\n        }\r\n    }\r\n}"]}]}